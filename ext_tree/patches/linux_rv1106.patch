diff -Naur original_dir/sound/soc/rockchip/rockchip_i2s_tdm.c modified_dir/sound/soc/rockchip/rockchip_i2s_tdm.c
--- original_dir/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-03-12 14:48:17.000000000 +0300
+++ modified_dir/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-06-13 21:18:28.941588904 +0300
@@ -1,15 +1,12 @@
 /* sound/soc/rockchip/rockchip_i2s_tdm.c
  *
  * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ * Enhanced with Audiophile Processing (Fixed for Buildroot)
  *
  * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
  * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Audiophile Enhancement: 2025
  */
-
 #include <linux/module.h>
 #include <linux/mfd/syscon.h>
 #include <linux/delay.h>
@@ -23,15 +20,23 @@
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
+#include <linux/random.h>
+#include <linux/math64.h>
+#include <linux/version.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
 
-#include "rockchip_i2s_tdm.h"
-//#include "rockchip_dlp.h"
+/* Условная компиляция NEON */
+#ifdef CONFIG_KERNEL_MODE_NEON
+#include <linux/kernel.h>
+#include <asm/neon.h>
+#include <asm/simd.h>
+#define HAVE_NEON_SUPPORT
+#endif
 
-//+++
-//#define DBGOUT(msg...)		do { printk(msg); } while (0)
-//+++
+#include "rockchip_i2s_tdm.h"
+#include "rockchip_dlp.h"
 
 #define DRV_NAME "rockchip-i2s-tdm"
 
@@ -50,317 +55,846 @@
 #define QUIRK_ALWAYS_ON				BIT(0)
 #define QUIRK_HDMI_PATH				BIT(1)
 
+/* Структура для аудиофильской обработки (упрощенная версия) */
+struct rk_audiophile_processor {
+    /* Логарифмические коэффициенты громкости (фиксированная точка) */
+    int32_t volume_linear_q16;    // Q15.16 фиксированная точка (0-65536)
+    int32_t volume_db_q8;         // Q23.8 фиксированная точка (-96*256 - 0)
+    
+    /* Дизеринг */
+    uint32_t dither_state[4];     // Состояние PRNG для дизеринга
+    bool dither_enabled;          // Включен ли дизеринг
+    
+    /* Параметры формата */
+    unsigned int sample_rate;
+    unsigned int channels;
+    unsigned int bit_depth;
+    snd_pcm_format_t format;
+    
+    /* Статистика и метрики */
+    uint64_t samples_processed;
+    uint32_t peak_level;          // Пиковый уровень
+    bool clipping_detected;       // Обнаружение клиппинга
+};
+
 struct txrx_config {
-	u32 addr;
-	u32 reg;
-	u32 txonly;
-	u32 rxonly;
+    u32 addr;
+    u32 reg;
+    u32 txonly;
+    u32 rxonly;
 };
 
 struct rk_i2s_soc_data {
-	u32 softrst_offset;
-	u32 grf_reg_offset;
-	u32 grf_shift;
-	int config_count;
-	const struct txrx_config *configs;
-	int (*init)(struct device *dev, u32 addr);
+    u32 softrst_offset;
+    u32 grf_reg_offset;
+    u32 grf_shift;
+    int config_count;
+    const struct txrx_config *configs;
+    int (*init)(struct device *dev, u32 addr);
 };
 
 struct rk_i2s_tdm_dev {
-	struct device *dev;
-	struct clk *hclk;
-	struct clk *mclk_tx;
-	struct clk *mclk_rx;
-	/* The mclk_tx_src is parent of mclk_tx */
-	struct clk *mclk_tx_src;
-	/* The mclk_rx_src is parent of mclk_rx */
-	struct clk *mclk_rx_src;
-	/*
-	 * The mclk_root0 and mclk_root1 are root parent and supplies for
-	 * the different FS.
-	 *
-	 * e.g:
-	 * mclk_root0 is VPLL0, used for FS=48000Hz
-	 * mclk_root0 is VPLL1, used for FS=44100Hz
-	 */
-	struct clk *mclk_root0;
-	struct clk *mclk_root1;
+    struct device *dev;
+    struct clk *hclk;
+    struct clk *mclk_tx;
+    struct clk *mclk_rx;
+    /* The mclk_tx_src is parent of mclk_tx */
+    struct clk *mclk_tx_src;
+    /* The mclk_rx_src is parent of mclk_rx */
+    struct clk *mclk_rx_src;
+    /*
+     * The mclk_root0 and mclk_root1 are root parent and supplies for
+     * the different FS.
+     */
+    struct clk *mclk_root0;
+    struct clk *mclk_root1;
 //+++
-	//+++c
-	struct clk *hclk_root;
-	bool hclk_root_f;
-	unsigned int hclk_root_x;
-	unsigned int dma_burst, dma_bytes;
-	//+++c
-	bool mclk_external;
-	bool mclk_ext_mux;
-	bool s2mono;
-	struct clk *mclk_ext;
-	struct clk *clk_44;
-	struct clk *clk_48;
-	int dcount;
-	unsigned int frame_width;
+    bool mclk_external;
+    bool mclk_ext_mux;
+    struct clk *mclk_ext;
+    struct clk *clk_44;
+    struct clk *clk_48;
 //+++
-	struct regmap *regmap;
-	struct regmap *grf;
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-	struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
-	struct reset_control *tx_reset;
-	struct reset_control *rx_reset;
-	const struct rk_i2s_soc_data *soc_data;
+    struct regmap *regmap;
+    struct regmap *grf;
+    struct snd_dmaengine_dai_dma_data capture_dma_data;
+    struct snd_dmaengine_dai_dma_data playback_dma_data;
+    struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
+    struct reset_control *tx_reset;
+    struct reset_control *rx_reset;
+    const struct rk_i2s_soc_data *soc_data;
 #ifdef HAVE_SYNC_RESET
-	void __iomem *cru_base;
-	int tx_reset_id;
-	int rx_reset_id;
+    void __iomem *cru_base;
+    int tx_reset_id;
+    int rx_reset_id;
 #endif
-	bool is_master_mode;
-	bool io_multiplex;
-	bool mclk_calibrate;
-	bool tdm_mode;
-	bool tdm_fsync_half_frame;
-	unsigned int mclk_rx_freq;
-	unsigned int mclk_tx_freq;
-	unsigned int mclk_root0_freq;
-	unsigned int mclk_root1_freq;
-	unsigned int mclk_root0_initial_freq;
-	unsigned int mclk_root1_initial_freq;
-	unsigned int bclk_fs;
-	unsigned int clk_trcm;
-	unsigned int i2s_sdis[CH_GRP_MAX];
-	unsigned int i2s_sdos[CH_GRP_MAX];
-	unsigned int quirks;
-	int clk_ppm;
-	atomic_t refcount;
-	spinlock_t lock; /* xfer lock */
+    bool is_master_mode;
+    bool io_multiplex;
+    bool mclk_calibrate;
+    bool tdm_mode;
+    bool tdm_fsync_half_frame;
+    unsigned int mclk_rx_freq;
+    unsigned int mclk_tx_freq;
+    unsigned int mclk_root0_freq;
+    unsigned int mclk_root1_freq;
+    unsigned int mclk_root0_initial_freq;
+    unsigned int mclk_root1_initial_freq;
+    unsigned int bclk_fs;
+    unsigned int clk_trcm;
+    unsigned int i2s_sdis[CH_GRP_MAX];
+    unsigned int i2s_sdos[CH_GRP_MAX];
+    unsigned int quirks;
+    int clk_ppm;
+    atomic_t refcount;
+    spinlock_t lock; /* xfer lock */
+    int volume;
+    bool mute;
+    struct gpio_desc *mute_gpio;
+    
+    /* Аудиофильский процессор */
+    struct rk_audiophile_processor *audio_proc;
+    spinlock_t audio_proc_lock;   // Защита для обработки в реальном времени
+    
+    /* Добавить состояние паузы */
+    bool playback_paused;
+    bool capture_paused;
 };
 
 static struct i2s_of_quirks {
-	char *quirk;
-	int id;
+    char *quirk;
+    int id;
 } of_quirks[] = {
-	{
-		.quirk = "rockchip,always-on",
-		.id = QUIRK_ALWAYS_ON,
-	},
-	{
-		.quirk = "rockchip,hdmi-path",
-		.id = QUIRK_HDMI_PATH,
-	},
-};
+    {
+    .quirk = "rockchip,always-on",
+    .id = QUIRK_ALWAYS_ON,
+    },
+    {
+    .quirk = "rockchip,hdmi-path",
+    .id = QUIRK_HDMI_PATH,
+    },
+};
+
+/* Простая ЛИНЕЙНАЯ таблица для тестирования плавности */
+/* Каждый процент = 655 единиц (65536/100) */
+static const int32_t volume_linear_table[101] = {
+    0,     655,   1310,  1965,  2621,  3276,  3931,  4586,  5242,  5897,   // 0-9%
+    6552,  7207,  7863,  8518,  9173,  9828,  10484, 11139, 11794, 12449, // 10-19%
+    13105, 13760, 14415, 15070, 15726, 16381, 17036, 17691, 18347, 19002, // 20-29%
+    19657, 20312, 20968, 21623, 22278, 22933, 23589, 24244, 24899, 25554, // 30-39%
+    26210, 26865, 27520, 28175, 28831, 29486, 30141, 30796, 31452, 32107, // 40-49%
+    32762, 33417, 34073, 34728, 35383, 36038, 36694, 37349, 38004, 38659, // 50-59%
+    39315, 39970, 40625, 41280, 41936, 42591, 43246, 43901, 44557, 45212, // 60-69%
+    45867, 46522, 47178, 47833, 48488, 49143, 49799, 50454, 51109, 51764, // 70-79%
+    52420, 53075, 53730, 54385, 55041, 55696, 56351, 57006, 57662, 58317, // 80-89%
+    58972, 59627, 60283, 60938, 61593, 62248, 62904, 63559, 64214, 64869, // 90-99%
+    65536  // 100% = 1.0 в Q15.16
+};
+
+/* Упрощенная dB таблица - пока не используется */
+static const int32_t volume_db_table[101] = {
+    -15360, -2048, -1792, -1600, -1458, -1344, -1248, -1168, -1098, -1038, // 0-9%
+    -984,  -936,  -892,  -852,  -816,  -782,  -750,  -720,  -692,  -666,  // 10-19%
+    -640,  -616,  -594,  -572,  -552,  -532,  -514,  -496,  -478,  -462,  // 20-29%
+    -446,  -430,  -416,  -402,  -388,  -374,  -362,  -350,  -338,  -326,  // 30-39%
+    -316,  -306,  -296,  -286,  -276,  -268,  -260,  -252,  -244,  -236,  // 40-49%
+    -228,  -222,  -216,  -210,  -204,  -198,  -192,  -186,  -182,  -178,  // 50-59%
+    -174,  -170,  -166,  -162,  -158,  -154,  -150,  -146,  -142,  -138,  // 60-69%
+    -134,  -130,  -126,  -122,  -118,  -114,  -110,  -106,  -102,  -98,   // 70-79%
+    -94,   -90,   -86,   -82,   -78,   -74,   -70,   -66,   -62,   -58,   // 80-89%
+    -54,   -50,   -46,   -42,   -38,   -34,   -30,   -26,   -22,   -18,   // 90-99%
+    0      // 100% = 0dB
+};
+
+/* Простая LFSR для дизеринга без float операций */
+static inline uint32_t simple_lfsr(uint32_t *state)
+{
+    uint32_t bit = ((*state >> 0) ^ (*state >> 2) ^ (*state >> 3) ^ (*state >> 5)) & 1;
+    *state = (*state >> 1) | (bit << 15);
+    return *state;
+}
+
+/* Генерация TPDF дизеринга с фиксированной точкой */
+static inline int32_t generate_dither_tpdf(struct rk_audiophile_processor *proc, int bit_depth)
+{
+    uint32_t rand1 = simple_lfsr(&proc->dither_state[0]);
+    uint32_t rand2 = simple_lfsr(&proc->dither_state[1]);
+    
+    int32_t dither = (int32_t)(rand1 + rand2) - 65536; // TPDF: sum of two uniform distributions
+    
+    /* Масштабируем для соответствующей битности */
+    switch (bit_depth) {
+        case 16: return dither >> 1;        // 1 LSB для 16-бит
+        case 24: return dither >> 9;        // 1 LSB для 24-бит
+        case 32: return dither >> 17;       // 1 LSB для 32-бит
+        default: return dither >> 1;
+    }
+}
+
+/* Оптимизированная обработка стерео 16-бит с фиксированной точкой */
+static void process_stereo_16bit_fixed(struct rk_audiophile_processor *proc,
+                                      int16_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int32_t left, right;
+    
+    for (i = 0; i < frames; i++) {
+        /* Обрабатываем левый канал */
+        left = (int32_t)buffer[i * 2];
+        left = (left * volume) >> 16; // Q15.16 умножение
+        
+        /* Обрабатываем правый канал */
+        right = (int32_t)buffer[i * 2 + 1];
+        right = (right * volume) >> 16;
+        
+        /* Добавляем дизеринг если включен */
+        if (proc->dither_enabled) {
+            left += generate_dither_tpdf(proc, 16);
+            right += generate_dither_tpdf(proc, 16);
+        }
+        
+        /* Ограничение и обнаружение клиппинга */
+        if (left > 32767) {
+            left = 32767;
+            proc->clipping_detected = true;
+        } else if (left < -32768) {
+            left = -32768;
+            proc->clipping_detected = true;
+        }
+        
+        if (right > 32767) {
+            right = 32767;
+            proc->clipping_detected = true;
+        } else if (right < -32768) {
+            right = -32768;
+            proc->clipping_detected = true;
+        }
+        
+        buffer[i * 2] = (int16_t)left;
+        buffer[i * 2 + 1] = (int16_t)right;
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+
+/* Быстрая обработка стерео 32-бит без дизеринга для высоких частот */
+static void process_stereo_32bit_fast(struct rk_audiophile_processor *proc,
+                                     int32_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int64_t left, right;
+    
+    /* Простая обработка без дизеринга и детальных проверок */
+    for (i = 0; i < frames; i++) {
+        left = ((int64_t)buffer[i * 2] * volume) >> 16;
+        right = ((int64_t)buffer[i * 2 + 1] * volume) >> 16;
+        
+        /* Быстрое ограничение без детального анализа клиппинга */
+        if (left > 2147483647LL) left = 2147483647LL;
+        else if (left < -2147483648LL) left = -2147483648LL;
+        
+        if (right > 2147483647LL) right = 2147483647LL;
+        else if (right < -2147483648LL) right = -2147483648LL;
+        
+        buffer[i * 2] = (int32_t)left;
+        buffer[i * 2 + 1] = (int32_t)right;
+    }
+}
+
+/* Быстрая обработка стерео 16-бит без дизеринга для высоких частот */
+static void process_stereo_16bit_fast(struct rk_audiophile_processor *proc,
+                                     int16_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int32_t left, right;
+    
+    for (i = 0; i < frames; i++) {
+        left = ((int32_t)buffer[i * 2] * volume) >> 16;
+        right = ((int32_t)buffer[i * 2 + 1] * volume) >> 16;
+        
+        /* Быстрое ограничение */
+        if (left > 32767) left = 32767;
+        else if (left < -32768) left = -32768;
+        
+        if (right > 32767) right = 32767;
+        else if (right < -32768) right = -32768;
+        
+        buffer[i * 2] = (int16_t)left;
+        buffer[i * 2 + 1] = (int16_t)right;
+    }
+}
+
+/* Оптимизированная обработка стерео 32-бит с фиксированной точкой */
+static void process_stereo_32bit_fixed(struct rk_audiophile_processor *proc,
+                                      int32_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int64_t left, right; /* Используем 64-bit для предотвращения переполнения */
+    
+    for (i = 0; i < frames; i++) {
+        /* Обрабатываем левый канал (32-bit) */
+        left = (int64_t)buffer[i * 2];
+        left = (left * volume) >> 16;
+        
+        /* Обрабатываем правый канал */
+        right = (int64_t)buffer[i * 2 + 1];
+        right = (right * volume) >> 16;
+        
+        /* Добавляем дизеринг если включен */
+        if (proc->dither_enabled) {
+            left += generate_dither_tpdf(proc, 32);
+            right += generate_dither_tpdf(proc, 32);
+        }
+        
+        /* Ограничение для 32-бит */
+        if (left > 2147483647LL) {
+            left = 2147483647LL;
+            proc->clipping_detected = true;
+        } else if (left < -2147483648LL) {
+            left = -2147483648LL;
+            proc->clipping_detected = true;
+        }
+        
+        if (right > 2147483647LL) {
+            right = 2147483647LL;
+            proc->clipping_detected = true;
+        } else if (right < -2147483648LL) {
+            right = -2147483648LL;
+            proc->clipping_detected = true;
+        }
+        
+        buffer[i * 2] = (int32_t)left;
+        buffer[i * 2 + 1] = (int32_t)right;
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+
+/* Оптимизированная обработка стерео 24-бит с фиксированной точкой */
+static void process_stereo_24bit_fixed(struct rk_audiophile_processor *proc,
+                                      int32_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int32_t left, right;
+    
+    for (i = 0; i < frames; i++) {
+        /* Обрабатываем левый канал (24-бит в 32-бит контейнере) */
+        left = (buffer[i * 2] << 8) >> 8;  // Знаковое расширение до 24-бит
+        left = (left * volume) >> 16;
+        
+        /* Обрабатываем правый канал */
+        right = (buffer[i * 2 + 1] << 8) >> 8;
+        right = (right * volume) >> 16;
+        
+        /* Добавляем дизеринг если включен */
+        if (proc->dither_enabled) {
+            left += generate_dither_tpdf(proc, 24);
+            right += generate_dither_tpdf(proc, 24);
+        }
+        
+        /* Ограничение для 24-бит */
+        if (left > 8388607) {
+            left = 8388607;
+            proc->clipping_detected = true;
+        } else if (left < -8388608) {
+            left = -8388608;
+            proc->clipping_detected = true;
+        }
+        
+        if (right > 8388607) {
+            right = 8388607;
+            proc->clipping_detected = true;
+        } else if (right < -8388608) {
+            right = -8388608;
+            proc->clipping_detected = true;
+        }
+        
+        /* Маскируем до 24 бит */
+        buffer[i * 2] = left & 0x00FFFFFF;
+        buffer[i * 2 + 1] = right & 0x00FFFFFF;
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+
+#ifdef HAVE_NEON_SUPPORT
+/* NEON версия для систем с поддержкой NEON */
+static void process_stereo_16bit_neon(struct rk_audiophile_processor *proc,
+                                     int16_t *buffer, size_t frames)
+{
+    size_t neon_frames, i;
+    
+    /* Если NEON доступен в kernel mode, используем его */
+    if (may_use_simd()) {
+        kernel_neon_begin();
+        
+        /* Простая NEON версия без сложных float операций */
+        neon_frames = frames & ~3; // Кратно 4
+        
+        for (i = 0; i < neon_frames; i += 4) {
+            /* Здесь можно добавить NEON ассемблерные инструкции */
+            /* Для простоты используем обычную обработку */
+            process_stereo_16bit_fixed(proc, &buffer[i * 2], 4);
+        }
+        
+        /* Обрабатываем остаток обычным способом */
+        for (; i < frames; i++) {
+            process_stereo_16bit_fixed(proc, &buffer[i * 2], 1);
+        }
+        
+        kernel_neon_end();
+    } else {
+        /* Fallback на обычную обработку */
+        process_stereo_16bit_fixed(proc, buffer, frames);
+    }
+}
+#endif
+
+/* Основная функция обработки аудио */
+static int rockchip_audiophile_process_buffer(struct rk_i2s_tdm_dev *i2s_tdm,
+                                            void *buffer, size_t buffer_size)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    size_t frame_size, frames;
+    static int call_count = 0; /* Счетчик вызовов для отладки */
+    static bool debug_samples = true; /* Вывод первых сэмплов для отладки */
+    static bool high_rate_warning_shown = false;
+    
+    if (!proc) {
+        dev_warn_ratelimited(i2s_tdm->dev, "Audio processor not initialized\n");
+        return 0;
+    }
+    
+    /* ВАЖНО: Отключаем обработку для высоких частот дискретизации (> 192 кГц) */
+    /* Это критично для 352.8/384 кГц - процессор не успевает! */
+    if (proc->sample_rate > 192000) {
+        if (!high_rate_warning_shown) {
+            dev_info(i2s_tdm->dev, "High sample rate detected (%d Hz) - disabling processing for performance\n", 
+                     proc->sample_rate);
+            high_rate_warning_shown = true;
+        }
+        /* Пропускаем обработку для высоких частот */
+        return 0;
+    }
+    
+    if (i2s_tdm->mute) {
+        /* Быстрый путь - заполняем тишиной при mute */
+        memset(buffer, 0, buffer_size);
+        
+        /* Отладочное сообщение только для первых вызовов */
+        if (call_count < 5) {
+            dev_info(i2s_tdm->dev, "Audio processing: MUTED (call %d)\n", call_count++);
+        }
+        return 0;
+    }
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    frame_size = (proc->bit_depth / 8) * proc->channels;
+    frames = buffer_size / frame_size;
+    
+    proc->clipping_detected = false;
+    
+    /* Отладочное сообщение только для первых вызовов */
+    if (call_count < 5) {
+        dev_info(i2s_tdm->dev, 
+                 "Audio processing: %zu frames, %dbit, %dch, %dHz, vol=0x%x (call %d)\n",
+                 frames, proc->bit_depth, proc->channels, proc->sample_rate,
+                 proc->volume_linear_q16, call_count++);
+    } else if (call_count == 5) {
+        dev_info(i2s_tdm->dev, "Audio processing working, suppressing further debug messages\n");
+        call_count++;
+    }
+    
+    /* Отладочный вывод первых сэмплов для 32-bit */
+    if (debug_samples && proc->format == SNDRV_PCM_FORMAT_S32_LE && frames > 0) {
+        int32_t *samples = (int32_t*)buffer;
+        dev_info(i2s_tdm->dev, "First samples BEFORE: [0]=%d [1]=%d [2]=%d [3]=%d\n",
+                 samples[0], samples[1], samples[2], samples[3]);
+    }
+    
+    /* Простая обработка объема для тестирования - применяем только если громкость не 100% */
+    if (proc->volume_linear_q16 != 65536) {
+        /* Выбираем функцию обработки в зависимости от формата */
+        switch (proc->format) {
+            case SNDRV_PCM_FORMAT_S16_LE:
+                if (proc->channels == 2) {
+#ifdef HAVE_NEON_SUPPORT
+                    process_stereo_16bit_neon(proc, (int16_t*)buffer, frames);
+#else
+                    process_stereo_16bit_fixed(proc, (int16_t*)buffer, frames);
+#endif
+                }
+                break;
+                
+            case SNDRV_PCM_FORMAT_S24_LE:
+                if (proc->channels == 2) {
+                    process_stereo_24bit_fixed(proc, (int32_t*)buffer, frames);
+                }
+                break;
+                
+            case SNDRV_PCM_FORMAT_S32_LE:
+            case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+                if (proc->channels == 2) {
+                    process_stereo_32bit_fixed(proc, (int32_t*)buffer, frames);
+                }
+                break;
+                
+            default:
+                /* Fallback - не обрабатываем неподдерживаемые форматы */
+                spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+                dev_warn_ratelimited(i2s_tdm->dev, "Unsupported audio format: %d\n", proc->format);
+                return 0;
+        }
+    }
+    
+    /* Отладочный вывод первых сэмплов ПОСЛЕ обработки */
+    if (debug_samples && proc->format == SNDRV_PCM_FORMAT_S32_LE && frames > 0) {
+        int32_t *samples = (int32_t*)buffer;
+        dev_info(i2s_tdm->dev, "First samples AFTER: [0]=%d [1]=%d [2]=%d [3]=%d\n",
+                 samples[0], samples[1], samples[2], samples[3]);
+        debug_samples = false; /* Показать только один раз */
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    if (proc->clipping_detected) {
+        dev_warn_ratelimited(i2s_tdm->dev, 
+                           "Audiophile: Clipping detected at volume %d%%\n", 
+                           i2s_tdm->volume);
+    }
+    
+    return 0;
+}
+
+/* Обновление параметров аудиофильской обработки */
+static void rockchip_audiophile_update_volume(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    
+    if (!proc) return;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    /* Используем предвычисленные таблицы */
+    if (i2s_tdm->volume >= 0 && i2s_tdm->volume <= 100) {
+        proc->volume_db_q8 = volume_db_table[i2s_tdm->volume];
+        proc->volume_linear_q16 = volume_linear_table[i2s_tdm->volume];
+    } else {
+        proc->volume_db_q8 = -24576; // -96dB
+        proc->volume_linear_q16 = 0;
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    /* Логирование без float операций - используем целочисленное представление */
+    dev_info(i2s_tdm->dev, 
+             "Audiophile: Volume %d%% = %d/256 dB (linear: 0x%x, mute: %s)\n",
+             i2s_tdm->volume, 
+             proc->volume_db_q8,
+             proc->volume_linear_q16,
+             i2s_tdm->mute ? "ON" : "OFF");
+}
+
+/* Обновление параметров при изменении формата */
+static int rockchip_audiophile_set_format(struct rk_i2s_tdm_dev *i2s_tdm,
+                                         struct snd_pcm_hw_params *params)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    
+    if (!proc) return 0;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    proc->sample_rate = params_rate(params);
+    proc->channels = params_channels(params);
+    proc->format = params_format(params);
+    
+    switch (proc->format) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            proc->bit_depth = 16;
+            break;
+        case SNDRV_PCM_FORMAT_S20_3LE:
+            proc->bit_depth = 20;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            proc->bit_depth = 24;
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+        case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+            proc->bit_depth = 32;
+            break;
+        default:
+            proc->bit_depth = 16;
+            break;
+    }
+    
+    /* Сброс статистики */
+    proc->samples_processed = 0;
+    proc->peak_level = 0;
+    proc->clipping_detected = false;
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    dev_info(i2s_tdm->dev, 
+             "Audiophile: Format updated - %dHz, %dch, %dbit\n",
+             proc->sample_rate, proc->channels, proc->bit_depth);
+    
+    return 0;
+}
+
+/* Инициализация аудиофильского процессора */
+static int rockchip_audiophile_init(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    struct rk_audiophile_processor *proc;
+    
+    proc = devm_kzalloc(i2s_tdm->dev, sizeof(*proc), GFP_KERNEL);
+    if (!proc)
+        return -ENOMEM;
+    
+    /* Инициализация параметров */
+    proc->volume_linear_q16 = 65536;  // 100% = 1.0 в Q15.16
+    proc->volume_db_q8 = 0;           // 0dB в Q23.8
+    proc->dither_enabled = false;     // Отключаем дизеринг по умолчанию для отладки
+    
+    /* Инициализация PRNG для дизеринга */
+    get_random_bytes(proc->dither_state, sizeof(proc->dither_state));
+    
+    /* Убеждаемся что состояние не равно 0 (для LFSR) */
+    if (proc->dither_state[0] == 0) proc->dither_state[0] = 0xACE1;
+    if (proc->dither_state[1] == 0) proc->dither_state[1] = 0xDEAD;
+    if (proc->dither_state[2] == 0) proc->dither_state[2] = 0xBEEF;
+    if (proc->dither_state[3] == 0) proc->dither_state[3] = 0xCAFE;
+    
+    i2s_tdm->audio_proc = proc;
+    spin_lock_init(&i2s_tdm->audio_proc_lock);
+    
+#ifdef HAVE_NEON_SUPPORT
+    dev_info(i2s_tdm->dev, "Audiophile processor initialized with NEON support (dither OFF)\n");
+#else
+    dev_info(i2s_tdm->dev, "Audiophile processor initialized (fixed-point mode, dither OFF)\n");
+#endif
+    
+    return 0;
+}
 
 static int to_ch_num(unsigned int val)
 {
-	int chs;
+    int chs;
 
-	switch (val) {
-	case I2S_CHN_4:
-		chs = 4;
-		break;
-	case I2S_CHN_6:
-		chs = 6;
-		break;
-	case I2S_CHN_8:
-		chs = 8;
-		break;
-	default:
-		chs = 2;
-		break;
-	}
+    switch (val) {
+    case I2S_CHN_4:
+    chs = 4;
+    break;
+    case I2S_CHN_6:
+    chs = 6;
+    break;
+    case I2S_CHN_8:
+    chs = 8;
+    break;
+    default:
+    chs = 2;
+    break;
+    }
 
-	return chs;
+    return chs;
 }
 
 static int i2s_tdm_runtime_suspend(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-
-	regcache_cache_only(i2s_tdm->regmap, true);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
+    regcache_cache_only(i2s_tdm->regmap, true);
+    clk_disable_unprepare(i2s_tdm->mclk_tx);
+    clk_disable_unprepare(i2s_tdm->mclk_rx);
 
-	return 0;
+    return 0;
 }
 
 static int i2s_tdm_runtime_resume(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int ret;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
 
-	ret = clk_prepare_enable(i2s_tdm->mclk_tx);
-	if (ret)
-		goto err_mclk_tx;
-
-	ret = clk_prepare_enable(i2s_tdm->mclk_rx);
-	if (ret)
-		goto err_mclk_rx;
-
-	regcache_cache_only(i2s_tdm->regmap, false);
-	regcache_mark_dirty(i2s_tdm->regmap);
-	ret = regcache_sync(i2s_tdm->regmap);
-	if (ret)
-		goto err_regmap;
+    ret = clk_prepare_enable(i2s_tdm->mclk_tx);
+    if (ret)
+    goto err_mclk_tx;
 
-	return 0;
+    ret = clk_prepare_enable(i2s_tdm->mclk_rx);
+    if (ret)
+    goto err_mclk_rx;
+
+    regcache_cache_only(i2s_tdm->regmap, false);
+    regcache_mark_dirty(i2s_tdm->regmap);
+
+    ret = regcache_sync(i2s_tdm->regmap);
+    if (ret)
+    goto err_regmap;
+
+    return 0;
 
 err_regmap:
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
+    clk_disable_unprepare(i2s_tdm->mclk_rx);
 err_mclk_rx:
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
+    clk_disable_unprepare(i2s_tdm->mclk_tx);
 err_mclk_tx:
-	return ret;
+    return ret;
 }
 
 static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
 {
-	return snd_soc_dai_get_drvdata(dai);
+    return snd_soc_dai_get_drvdata(dai);
 }
 
 static inline bool is_stream_active(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	unsigned int val;
+    unsigned int val;
 
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
+    regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		return (val & I2S_XFER_TXS_START);
-	else
-		return (val & I2S_XFER_RXS_START);
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return (val & I2S_XFER_TXS_START);
+    else
+    return (val & I2S_XFER_RXS_START);
 }
 
 #ifdef HAVE_SYNC_RESET
 #if defined(CONFIG_ARM) && !defined(writeq)
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
-	asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
+    asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
 }
 #define writeq(v,c) ({ __iowmb(); __raw_writeq((__force u64) cpu_to_le64(v), c); })
 #endif
 
 static void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
-	void __iomem *cru_reset, *addr;
-	unsigned long flags;
-	u64 val;
-
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
-
-	tx_id = i2s_tdm->tx_reset_id;
-	rx_id = i2s_tdm->rx_reset_id;
-	if (tx_id < 0 || rx_id < 0)
-		return;
-
-	tx_bank = tx_id / 16;
-	tx_offset = tx_id % 16;
-	rx_bank = rx_id / 16;
-	rx_offset = rx_id % 16;
-
-	dev_dbg(i2s_tdm->dev,
-		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
-		tx_bank, rx_bank, tx_offset, rx_offset);
-
-	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
-
-	switch (abs(tx_bank - rx_bank)) {
-	case 0:
-		writel(BIT(tx_offset) | BIT(rx_offset) |
-		       (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		break;
-	case 1:
-		if (tx_bank < rx_bank) {
-			val = BIT(rx_offset) | (BIT(rx_offset) << 16);
-			val <<= 32;
-			val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
-			addr = cru_reset + (tx_bank * 4);
-		} else {
-			val = BIT(tx_offset) | (BIT(tx_offset) << 16);
-			val <<= 32;
-			val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
-			addr = cru_reset + (rx_bank * 4);
-		}
-
-		if (IS_ALIGNED((uintptr_t)addr, 8)) {
-			writeq(val, addr);
-			break;
-		}
-		fallthrough;
-	default:
-		local_irq_save(flags);
-		writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
-		       cru_reset + (rx_bank * 4));
-		local_irq_restore(flags);
-		break;
-	}
-	/* delay for reset assert done */
-	udelay(10);
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel(BIT(tx_offset) | BIT(rx_offset) |
+           (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
+
+    /* delay for reset assert done */
+    udelay(10);
 }
 
 static void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
-	void __iomem *cru_reset, *addr;
-	unsigned long flags;
-	u64 val;
-
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
-
-	tx_id = i2s_tdm->tx_reset_id;
-	rx_id = i2s_tdm->rx_reset_id;
-	if (tx_id < 0 || rx_id < 0)
-		return;
-
-	tx_bank = tx_id / 16;
-	tx_offset = tx_id % 16;
-	rx_bank = rx_id / 16;
-	rx_offset = rx_id % 16;
-
-	dev_dbg(i2s_tdm->dev,
-		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
-		tx_bank, rx_bank, tx_offset, rx_offset);
-
-	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
-
-	switch (abs(tx_bank - rx_bank)) {
-	case 0:
-		writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		break;
-	case 1:
-		if (tx_bank < rx_bank) {
-			val = (BIT(rx_offset) << 16);
-			val <<= 32;
-			val |= (BIT(tx_offset) << 16);
-			addr = cru_reset + (tx_bank * 4);
-		} else {
-			val = (BIT(tx_offset) << 16);
-			val <<= 32;
-			val |= (BIT(rx_offset) << 16);
-			addr = cru_reset + (rx_bank * 4);
-		}
-
-		if (IS_ALIGNED((uintptr_t)addr, 8)) {
-			writeq(val, addr);
-			break;
-		}
-		fallthrough;
-	default:
-		local_irq_save(flags);
-		writel((BIT(tx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		writel((BIT(rx_offset) << 16),
-		       cru_reset + (rx_bank * 4));
-		local_irq_restore(flags);
-		break;
-	}
-	/* delay for reset deassert done */
-	udelay(10);
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel((BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel((BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
+
+    /* delay for reset deassert done */
+    udelay(10);
 }
 
 /*
@@ -369,16 +903,18 @@
  */
 static void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	rockchip_i2s_tdm_reset_assert(i2s_tdm);
-	rockchip_i2s_tdm_reset_deassert(i2s_tdm);
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
 }
 #else
 static inline void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
 static inline void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
 static inline void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
@@ -386,57 +922,59 @@
 
 static void rockchip_i2s_tdm_reset(struct reset_control *rc)
 {
-	if (IS_ERR_OR_NULL(rc))
-		return;
+    if (IS_ERR_OR_NULL(rc))
+    return;
 
-	reset_control_assert(rc);
-	/* delay for reset assert done */
-	udelay(10);
-	reset_control_deassert(rc);
-	/* delay for reset deassert done */
-	udelay(10);
+    reset_control_assert(rc);
+    /* delay for reset assert done */
+    udelay(10);
+
+    reset_control_deassert(rc);
+    /* delay for reset deassert done */
+    udelay(10);
 }
 
 static int rockchip_i2s_tdm_clear(struct rk_i2s_tdm_dev *i2s_tdm,
-				  unsigned int clr)
+      unsigned int clr)
 {
-	struct reset_control *rst = NULL;
-	unsigned int val = 0;
-	int ret = 0;
-
-	if (!i2s_tdm->is_master_mode)
-		goto reset;
-
-	switch (clr) {
-	case I2S_CLR_TXC:
-		rst = i2s_tdm->tx_reset;
-		break;
-	case I2S_CLR_RXC:
-		rst = i2s_tdm->rx_reset;
-		break;
-	case I2S_CLR_TXC | I2S_CLR_RXC:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
-	ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
-					      !(val & clr), 10, 100);
-	if (ret < 0) {
-		dev_warn(i2s_tdm->dev, "failed to clear %u\n", clr);
-		goto reset;
-	}
+    struct reset_control *rst = NULL;
+    unsigned int val = 0;
+    int ret = 0;
+
+    if (!i2s_tdm->is_master_mode)
+    goto reset;
+
+    switch (clr) {
+    case I2S_CLR_TXC:
+    rst = i2s_tdm->tx_reset;
+    break;
+    case I2S_CLR_RXC:
+    rst = i2s_tdm->rx_reset;
+    break;
+    case I2S_CLR_TXC | I2S_CLR_RXC:
+    break;
+    default:
+    return -EINVAL;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
+
+    ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
+              !(val & clr), 10, 100);
+    if (ret < 0) {
+    dev_warn(i2s_tdm->dev, "failed to clear %u\n", clr);
+    goto reset;
+    }
 
-	return 0;
+    return 0;
 
 reset:
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_sync_reset(i2s_tdm);
-	else
-		rockchip_i2s_tdm_reset(rst);
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_sync_reset(i2s_tdm);
+    else
+    rockchip_i2s_tdm_reset(rst);
 
-	return 0;
+    return 0;
 }
 
 /*
@@ -446,2088 +984,2601 @@
  */
 static void rockchip_i2s_tdm_tx_fifo_padding(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
 {
-	unsigned int val, w, c, i;
+    unsigned int val, w, c, i;
 
-	if (!en)
-		return;
+    if (!en)
+    return;
 
-	regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-	w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
-	c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
+    c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
 
-	for (i = 0; i < c; i++)
-		regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
+    for (i = 0; i < c; i++)
+    regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
 }
 
 static void rockchip_i2s_tdm_fifo_xrun_detect(struct rk_i2s_tdm_dev *i2s_tdm,
-					      int stream, bool en)
+              int stream, bool en)
 {
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* clear irq status which was asserted before TXUIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIE_MASK,
-				   I2S_INTCR_TXUIE(en));
-	} else {
-		/* clear irq status which was asserted before RXOIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIE_MASK,
-				   I2S_INTCR_RXOIE(en));
-	}
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    /* clear irq status which was asserted before TXUIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIE_MASK,
+       I2S_INTCR_TXUIE(en));
+    } else {
+    /* clear irq status which was asserted before RXOIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIE_MASK,
+       I2S_INTCR_RXOIE(en));
+    }
 }
 
 static void rockchip_i2s_tdm_dma_ctrl(struct rk_i2s_tdm_dev *i2s_tdm,
-				      int stream, bool en)
+          int stream, bool en)
 {
-	if (!en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
+    if (!en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
-			rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_TDE_MASK,
-				   I2S_DMACR_TDE(en));
-		/*
-		 * Explicitly delay 1 usec for dma to fill FIFO,
-		 * though there was a implied HW delay that around
-		 * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
-		 * to FIFO-pop.
-		 *
-		 * 1 usec is enough to fill at lease 4 entry each FIFO
-		 * @192k 8ch 32bit situation.
-		 */
-		udelay(1);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_RDE_MASK,
-				   I2S_DMACR_RDE(en));
-	}
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
+        rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_TDE_MASK,
+       I2S_DMACR_TDE(en));
+    /*
+     * Explicitly delay 1 usec for dma to fill FIFO,
+     * though there was a implied HW delay that around
+     * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
+     * to FIFO-pop.
+     *
+     * 1 usec is enough to fill at lease 4 entry each FIFO
+     * @192k 8ch 32bit situation.
+     */
+    udelay(1);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_RDE_MASK,
+       I2S_DMACR_RDE(en));
+    }
 
-	if (en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
+    if (en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
 }
 
 static void rockchip_i2s_tdm_xfer_start(struct rk_i2s_tdm_dev *i2s_tdm,
-					int stream)
+        int stream)
 {
-	if (i2s_tdm->clk_trcm) {
-		rockchip_i2s_tdm_reset_assert(i2s_tdm);
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_MASK |
-				   I2S_XFER_RXS_MASK,
-				   I2S_XFER_TXS_START |
-				   I2S_XFER_RXS_START);
-		rockchip_i2s_tdm_reset_deassert(i2s_tdm);
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_MASK,
-				   I2S_XFER_TXS_START);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_RXS_MASK,
-				   I2S_XFER_RXS_START);
-	}
+    if (i2s_tdm->clk_trcm) {
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK |
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_TXS_START |
+       I2S_XFER_RXS_START);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK,
+       I2S_XFER_TXS_START);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_RXS_START);
+    }
 }
 
 static void rockchip_i2s_tdm_xfer_stop(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int stream, bool force)
+           int stream, bool force)
 {
-	unsigned int msk, val, clr;
+    unsigned int msk, val, clr;
 
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
-		return;
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
+    return;
 
-	if (i2s_tdm->clk_trcm) {
-		msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
-		val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_TXC | I2S_CLR_RXC;
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_STOP;
-		clr = I2S_CLR_TXC;
-	} else {
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_RXC;
-	}
+    if (i2s_tdm->clk_trcm) {
+    msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
+    val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_TXC | I2S_CLR_RXC;
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    msk = I2S_XFER_TXS_MASK;
+    val = I2S_XFER_TXS_STOP;
+    clr = I2S_CLR_TXC;
+    } else {
+    msk = I2S_XFER_RXS_MASK;
+    val = I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_RXC;
+    }
 
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
 
-	/* delay for LRCK signal integrity */
-	udelay(150);
+    /* delay for LRCK signal integrity */
+    udelay(150);
 
-	rockchip_i2s_tdm_clear(i2s_tdm, clr);
+    rockchip_i2s_tdm_clear(i2s_tdm, clr);
 }
 
 static void rockchip_i2s_tdm_xfer_trcm_start(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	unsigned long flags;
+    unsigned long flags;
 
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_inc_return(&i2s_tdm->refcount) == 1)
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_inc_return(&i2s_tdm->refcount) == 1)
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_i2s_tdm_xfer_trcm_stop(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	unsigned long flags;
+    unsigned long flags;
 
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_dec_and_test(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_dec_and_test(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_i2s_tdm_trcm_pause(struct snd_pcm_substream *substream,
-					struct rk_i2s_tdm_dev *i2s_tdm)
+        struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int stream = substream->stream;
-	int bstream = SNDRV_PCM_STREAM_LAST - stream;
+    int stream = substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - stream;
 
-	/* disable dma for both tx and rx */
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
-	rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
+    /* disable dma for both tx and rx */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
 }
 
 static void rockchip_i2s_tdm_trcm_resume(struct snd_pcm_substream *substream,
-					 struct rk_i2s_tdm_dev *i2s_tdm)
+         struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
+
+    /*
+     * just resume bstream, because current stream will be
+     * startup in the trigger-cmd-START
+     */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+}
 
-	/*
-	 * just resume bstream, because current stream will be
-	 * startup in the trigger-cmd-START
-	 */
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
-	rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+/* Дополнительная функция для проверки состояния паузы */
+static bool rockchip_i2s_tdm_is_paused(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return i2s_tdm->playback_paused;
+    else
+    return i2s_tdm->capture_paused;
 }
 
 static void rockchip_i2s_tdm_start(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	/*
-	 * On HDMI-PATH-ALWAYS-ON situation, we almost keep XFER always on,
-	 * so, for new data start, suggested to STOP-CLEAR-START to make sure
-	 * data aligned.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-	}
-
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
-
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
-	else
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    /* Проверить, не находится ли поток в состоянии паузы */
+    if (rockchip_i2s_tdm_is_paused(i2s_tdm, stream)) {
+    dev_dbg(i2s_tdm->dev, "Stream is paused, not starting\n");
+    return;
+    }
+
+    /* Запускаем DMA и передачу всегда */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
+    
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    
+    /* Проверка mute с учетом аудиофильской обработки */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK && 
+        (i2s_tdm->mute || (i2s_tdm->audio_proc && i2s_tdm->audio_proc->volume_linear_q16 == 0))) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback started, applying mute or zero volume\n");
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    }
 }
 
 static void rockchip_i2s_tdm_stop(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm);
+    else
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
+    
+    /* Только логирование, без изменения состояния mute */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback stopped, mute state: %s\n", 
+        i2s_tdm->mute ? "enabled" : "disabled");
+    }
+}
+
+/* Новые функции для обработки pause/resume */
+static void rockchip_i2s_tdm_pause(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = true;
+    } else {
+    if (i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = true;
+    }
+
+    /* Отключить DMA, но сохранить состояние устройства */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    /* Для TRCM режима используем специальную функцию */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+    } else {
+    /* Для обычного режима приостанавливаем передачу */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_STOP);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_STOP);
+    }
+    }
+
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream paused\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
+}
+
+static void rockchip_i2s_tdm_resume(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (!i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = false;
+    } else {
+    if (!i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = false;
+    }
+
+    /* Для TRCM режима используем специальную функцию */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    } else {
+    /* Восстановить передачу данных */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_START);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_START);
+    }
+    }
 
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm);
-	else
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
+    /* Включить DMA */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
+
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream resumed\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
 }
 
 static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
-				    unsigned int fmt)
+        unsigned int fmt)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
-	unsigned int mask = 0, val = 0, tdm_val = 0;
-	int ret = 0;
-	bool is_tdm = i2s_tdm->tdm_mode;
-
-	pm_runtime_get_sync(cpu_dai->dev);
-	mask = I2S_CKR_MSS_MASK;
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBS_CFS:
-		val = I2S_CKR_MSS_MASTER;
-		i2s_tdm->is_master_mode = true;
-		break;
-	case SND_SOC_DAIFMT_CBM_CFM:
-		val = I2S_CKR_MSS_SLAVE;
-		i2s_tdm->is_master_mode = false;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = I2S_TXCR_IBM_RSJM;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = I2S_TXCR_IBM_LSJM;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		val = I2S_TXCR_IBM_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
-		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
-		break;
-	case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
-		val = I2S_TXCR_TFS_PCM;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-
-	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = I2S_RXCR_IBM_RSJM;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = I2S_RXCR_IBM_LSJM;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		val = I2S_RXCR_IBM_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
-		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
-		break;
-	case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
-		val = I2S_RXCR_TFS_PCM;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-
-	if (is_tdm) {
-		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-		case SND_SOC_DAIFMT_RIGHT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_LEFT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(1);
-			break;
-		case SND_SOC_DAIFMT_I2S:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(0);
-			break;
-		case SND_SOC_DAIFMT_DSP_A:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_DSP_B:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(4);
-			break;
-		default:
-			ret = -EINVAL;
-			goto err_pm_put;
-		}
-
-		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
-		if (i2s_tdm->tdm_fsync_half_frame)
-			tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
-		else
-			tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
-
-		mask = I2S_TXCR_TFS_MASK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-
-		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
-		       TDM_SHIFT_CTRL_MSK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-				   mask, tdm_val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-				   mask, tdm_val);
-
-		if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-			/* refine frame width for TDM_I2S_ONE_FRAME */
-			mask = TDM_FRAME_WIDTH_MSK;
-			tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-					   mask, tdm_val);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-					   mask, tdm_val);
-		}
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    unsigned int mask = 0, val = 0, tdm_val = 0;
+    int ret = 0;
+    bool is_tdm = i2s_tdm->tdm_mode;
+
+    pm_runtime_get_sync(cpu_dai->dev);
+
+    mask = I2S_CKR_MSS_MASK;
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+    val = I2S_CKR_MSS_MASTER;
+    i2s_tdm->is_master_mode = true;
+    break;
+    case SND_SOC_DAIFMT_CBM_CFM:
+    val = I2S_CKR_MSS_SLAVE;
+    i2s_tdm->is_master_mode = false;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+    mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_NB_IF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    case SND_SOC_DAIFMT_IB_NF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_IB_IF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+    mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_TXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_TXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_TXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_TXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+    mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_RXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_RXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_RXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_RXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    if (is_tdm) {
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_LEFT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(1);
+        break;
+    case SND_SOC_DAIFMT_I2S:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(0);
+        break;
+    case SND_SOC_DAIFMT_DSP_A:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_DSP_B:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(4);
+        break;
+    default:
+        ret = -EINVAL;
+        goto err_pm_put;
+    }
+
+    tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+    if (i2s_tdm->tdm_fsync_half_frame)
+        tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
+    else
+        tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+    mask = I2S_TXCR_TFS_MASK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+           TDM_SHIFT_CTRL_MSK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+       mask, tdm_val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+       mask, tdm_val);
+
+    if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+        /* refine frame width for TDM_I2S_ONE_FRAME */
+        mask = TDM_FRAME_WIDTH_MSK;
+        tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, tdm_val);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, tdm_val);
+    }
+    }
 
 err_pm_put:
-	pm_runtime_put(cpu_dai->dev);
+    pm_runtime_put(cpu_dai->dev);
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct clk *clk, unsigned long rate,
-					 int ppm)
+         struct clk *clk, unsigned long rate,
+         int ppm)
 {
-	unsigned long rate_target;
-	int delta, ret;
+    unsigned long rate_target;
+    int delta, ret;
 
-	if (ppm == i2s_tdm->clk_ppm)
-		return 0;
+    if (ppm == i2s_tdm->clk_ppm)
+    return 0;
 
-	ret = rockchip_pll_clk_compensation(clk, ppm);
-	if (ret != -ENOSYS)
-		goto out;
+    ret = rockchip_pll_clk_compensation(clk, ppm);
+    if (ret != -ENOSYS)
+    goto out;
 
-	delta = (ppm < 0) ? -1 : 1;
-	delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
+    delta = (ppm < 0) ? -1 : 1;
+    delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
 
-	rate_target = rate + delta;
+    rate_target = rate + delta;
+    if (!rate_target)
+    return -EINVAL;
 
-	if (!rate_target)
-		return -EINVAL;
+    ret = clk_set_rate(clk, rate_target);
+    if (ret)
+    return ret;
 
-	ret = clk_set_rate(clk, rate_target);
-	if (ret)
-		return ret;
 out:
-	if (!ret)
-		i2s_tdm->clk_ppm = ppm;
+    if (!ret)
+    i2s_tdm->clk_ppm = ppm;
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-					   struct snd_pcm_substream *substream,
-					   unsigned int lrck_freq)
+           struct snd_pcm_substream *substream,
+           unsigned int lrck_freq)
 {
-	struct clk *mclk_root;
-	struct clk *mclk_parent;
-	unsigned int mclk_root_freq;
-	unsigned int mclk_root_initial_freq;
-	unsigned int mclk_parent_freq;
-	unsigned int div, delta;
-	uint64_t ppm;
-	int ret;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		mclk_parent = i2s_tdm->mclk_tx_src;
-	else
-		mclk_parent = i2s_tdm->mclk_rx_src;
-
-	switch (lrck_freq) {
-	case 8000:
-	case 16000:
-	case 24000:
-	case 32000:
-	case 48000:
-	case 64000:
-	case 96000:
-	case 192000:
-		mclk_root = i2s_tdm->mclk_root0;
-		mclk_root_freq = i2s_tdm->mclk_root0_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
-		break;
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-	case 176400:
-		mclk_root = i2s_tdm->mclk_root1;
-		mclk_root_freq = i2s_tdm->mclk_root1_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
-		break;
-	default:
-		dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
-			lrck_freq);
-		return -EINVAL;
-	}
-
-	ret = clk_set_parent(mclk_parent, mclk_root);
-	if (ret)
-		goto out;
-
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
-					    mclk_root_freq, 0);
-	if (ret)
-		goto out;
-
-	delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
-	ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
-
-	if (ppm) {
-		div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
-		if (!div)
-			return -EINVAL;
-
-		mclk_root_freq = mclk_parent_freq * round_up(div, 2);
-
-		ret = clk_set_rate(mclk_root, mclk_root_freq);
-		if (ret)
-			goto out;
-
-		i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
-	}
-
-	ret = clk_set_rate(mclk_parent, mclk_parent_freq);
-	if (ret)
-		goto out;
+    struct clk *mclk_root;
+    struct clk *mclk_parent;
+    unsigned int mclk_root_freq;
+    unsigned int mclk_root_initial_freq;
+    unsigned int mclk_parent_freq;
+    unsigned int div, delta;
+    uint64_t ppm;
+    int ret;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    mclk_parent = i2s_tdm->mclk_tx_src;
+    else
+    mclk_parent = i2s_tdm->mclk_rx_src;
+
+    switch (lrck_freq) {
+    case 8000:
+    case 16000:
+    case 24000:
+    case 32000:
+    case 48000:
+    case 64000:
+    case 96000:
+    case 192000:
+    case 384000:
+    mclk_root = i2s_tdm->mclk_root0;
+    mclk_root_freq = i2s_tdm->mclk_root0_freq;
+    mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
+    mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+    break;
+    case 11025:
+    case 22050:
+    case 44100:
+    case 88200:
+    case 176400:
+    case 352800:
+    mclk_root = i2s_tdm->mclk_root1;
+    mclk_root_freq = i2s_tdm->mclk_root1_freq;
+    mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
+    mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+    break;
+    default:
+    dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
+        lrck_freq);
+    return -EINVAL;
+    }
+
+    ret = clk_set_parent(mclk_parent, mclk_root);
+    if (ret)
+    goto out;
+
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
+            mclk_root_freq, 0);
+    if (ret)
+    goto out;
+
+    delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
+    ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
+
+    if (ppm) {
+    div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
+    if (!div)
+        return -EINVAL;
+
+    mclk_root_freq = mclk_parent_freq * round_up(div, 2);
+
+    ret = clk_set_rate(mclk_root, mclk_root_freq);
+    if (ret)
+        goto out;
+
+    i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
+    i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
+    }
+
+    ret = clk_set_rate(mclk_parent, mclk_parent_freq);
+    if (ret)
+    goto out;
 
 out:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-				     struct snd_pcm_substream *substream,
-				     struct clk **mclk)
+         struct snd_pcm_substream *substream,
+         struct clk **mclk)
 {
-	unsigned int mclk_freq;
-	int ret;
+    unsigned int mclk_freq;
+    int ret;
 
-	if (i2s_tdm->clk_trcm) {
-		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
-			dev_err(i2s_tdm->dev,
-				"clk_trcm, tx: %d and rx: %d should be same\n",
-				i2s_tdm->mclk_tx_freq,
-				i2s_tdm->mclk_rx_freq);
-			ret = -EINVAL;
-			goto err;
-		}
-
-		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
-		if (ret)
-			goto err;
-
-		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
-		if (ret)
-			goto err;
-
-		/* mclk_rx is also ok. */
-		*mclk = i2s_tdm->mclk_tx;
-	} else {
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			*mclk = i2s_tdm->mclk_tx;
-			mclk_freq = i2s_tdm->mclk_tx_freq;
-		} else {
-			*mclk = i2s_tdm->mclk_rx;
-			mclk_freq = i2s_tdm->mclk_rx_freq;
-		}
-
-		ret = clk_set_rate(*mclk, mclk_freq);
-		if (ret)
-			goto err;
-	}
+    if (i2s_tdm->clk_trcm) {
+    if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+        dev_err(i2s_tdm->dev,
+    "clk_trcm, tx: %d and rx: %d should be same\n",
+    i2s_tdm->mclk_tx_freq,
+    i2s_tdm->mclk_rx_freq);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+    if (ret)
+        goto err;
+
+    ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+    if (ret)
+        goto err;
+
+    /* mclk_rx is also ok. */
+    *mclk = i2s_tdm->mclk_tx;
+    } else {
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        *mclk = i2s_tdm->mclk_tx;
+        mclk_freq = i2s_tdm->mclk_tx_freq;
+    } else {
+        *mclk = i2s_tdm->mclk_rx;
+        mclk_freq = i2s_tdm->mclk_rx_freq;
+    }
+
+    ret = clk_set_rate(*mclk, mclk_freq);
+    if (ret)
+        goto err;
+    }
 
-	return 0;
+    return 0;
 
 err:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
-				     struct snd_soc_dai *dai)
+         struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int usable_chs = MULTIPLEX_CH_MAX;
-	unsigned int val = 0;
-
-	if (!i2s_tdm->io_multiplex)
-		return 0;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		struct snd_pcm_str *playback_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
-
-		if (playback_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-			val &= I2S_TXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		val &= I2S_RXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Capture chs(%d) > usable chs(%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-
-		switch (val) {
-		case I2S_CHN_4:
-			val = I2S_IO_6CH_OUT_4CH_IN;
-			break;
-		case I2S_CHN_6:
-			val = I2S_IO_4CH_OUT_6CH_IN;
-			break;
-		case I2S_CHN_8:
-			val = I2S_IO_2CH_OUT_8CH_IN;
-			break;
-		default:
-			val = I2S_IO_8CH_OUT_2CH_IN;
-			break;
-		}
-	} else {
-		struct snd_pcm_str *capture_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
-
-		if (capture_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-			val &= I2S_RXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		val &= I2S_TXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Playback chs(%d) > usable chs(%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-
-		switch (val) {
-		case I2S_CHN_4:
-			val = I2S_IO_4CH_OUT_6CH_IN;
-			break;
-		case I2S_CHN_6:
-			val = I2S_IO_6CH_OUT_4CH_IN;
-			break;
-		case I2S_CHN_8:
-			val = I2S_IO_8CH_OUT_2CH_IN;
-			break;
-		default:
-			val = I2S_IO_2CH_OUT_8CH_IN;
-			break;
-		}
-	}
-
-	val <<= i2s_tdm->soc_data->grf_shift;
-	val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
-	regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int usable_chs = MULTIPLEX_CH_MAX;
+    unsigned int val = 0;
+
+    if (!i2s_tdm->io_multiplex)
+    return 0;
+
+    if (IS_ERR(i2s_tdm->grf))
+    return 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+    struct snd_pcm_str *playback_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+
+    if (playback_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+        val &= I2S_TXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    val &= I2S_RXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Capture chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    default:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    }
+    } else {
+    struct snd_pcm_str *capture_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+    if (capture_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+        val &= I2S_RXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    val &= I2S_TXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Playback chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    default:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    }
+    }
+
+    val <<= i2s_tdm->soc_data->grf_shift;
+    val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
+    regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
 
-	return 0;
+    return 0;
 }
 
 static bool is_params_dirty(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai,
-			    unsigned int div_bclk,
-			    unsigned int div_lrck,
-			    unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
-
-	regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
-	last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
-	if (last_div_bclk != div_bclk)
-		return true;
-
-	regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
-	last_div_lrck = ((val & I2S_CKR_TSD_MASK) >> I2S_CKR_TSD_SHIFT) + 1;
-	if (last_div_lrck != div_lrck)
-		return true;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
-	} else {
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
-	}
-	if (last_fmt != fmt)
-		return true;
+            struct snd_soc_dai *dai,
+            unsigned int div_bclk,
+            unsigned int div_lrck,
+            unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
+
+    regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
+    last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
+    if (last_div_bclk != div_bclk)
+    return true;
+
+    regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
+    last_div_lrck = ((val & I2S_CKR_TSD_MASK) >> I2S_CKR_TSD_SHIFT) + 1;
+    if (last_div_lrck != div_lrck)
+    return true;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
+    } else {
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
+    }
+
+    if (last_fmt != fmt)
+    return true;
 
-	return false;
+    return false;
 }
 
 static int rockchip_i2s_tdm_params_trcm(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai,
-					unsigned int div_bclk,
-					unsigned int div_lrck,
-					unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned long flags;
-
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_read(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-			   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
-			   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
-			   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	else
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-
-	if (atomic_read(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+        struct snd_soc_dai *dai,
+        unsigned int div_bclk,
+        unsigned int div_lrck,
+        unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned long flags;
+
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+           I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+           I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+           I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    else
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params(struct snd_pcm_substream *substream,
-				   struct snd_soc_dai *dai,
-				   unsigned int div_bclk,
-				   unsigned int div_lrck,
-				   unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int stream = substream->stream;
-
-	if (is_stream_active(i2s_tdm, stream))
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_TXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_TSD_MASK,
-				   I2S_CKR_TSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_RSD_MASK,
-				   I2S_CKR_RSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-	}
-
-	/*
-	 * Bring back CLK ASAP after cfg changed to make SINK devices active
-	 * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
-	 * sound issue. at the moment, it's 8K@60Hz display situation.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	}
+       struct snd_soc_dai *dai,
+       unsigned int div_bclk,
+       unsigned int div_lrck,
+       unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int stream = substream->stream;
+
+    if (is_stream_active(i2s_tdm, stream))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_TSD_MASK,
+       I2S_CKR_TSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK,
+       I2S_CKR_RSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+    }
+
+    /*
+     * Bring back CLK ASAP after cfg changed to make SINK devices active
+     * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
+     * sound issue. at the moment, it's 8K@60Hz display situation.
+     */
+    if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
+        (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
+        (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    }
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params_channels(struct snd_pcm_substream *substream,
-					    struct snd_pcm_hw_params *params,
-					    struct snd_soc_dai *dai)
+            struct snd_pcm_hw_params *params,
+            struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int reg_fmt, fmt;
-	int ret = 0;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		reg_fmt = I2S_TXCR;
-	else
-		reg_fmt = I2S_RXCR;
-
-	regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
-	fmt &= I2S_TXCR_TFS_MASK;
-
-	if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-		switch (params_channels(params)) {
-		case 16:
-			ret = I2S_CHN_8;
-			break;
-		case 12:
-			ret = I2S_CHN_6;
-			break;
-		case 8:
-			ret = I2S_CHN_4;
-			break;
-		case 4:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	} else {
-		switch (params_channels(params)) {
-		case 8:
-			ret = I2S_CHN_8;
-			break;
-		case 6:
-			ret = I2S_CHN_6;
-			break;
-		case 4:
-			ret = I2S_CHN_4;
-			break;
-		case 2:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int reg_fmt, fmt;
+    int ret = 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    reg_fmt = I2S_TXCR;
+    else
+    reg_fmt = I2S_RXCR;
+
+    regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
+    fmt &= I2S_TXCR_TFS_MASK;
+
+    if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+    switch (params_channels(params)) {
+    case 16:
+        ret = I2S_CHN_8;
+        break;
+    case 12:
+        ret = I2S_CHN_6;
+        break;
+    case 8:
+        ret = I2S_CHN_4;
+        break;
+    case 4:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    } else {
+    switch (params_channels(params)) {
+    case 8:
+        ret = I2S_CHN_8;
+        break;
+    case 6:
+        ret = I2S_CHN_6;
+        break;
+    case 4:
+        ret = I2S_CHN_4;
+        break;
+    case 2:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    }
 
-	return ret;
+    return ret;
 }
 
+/* Обновленная функция hw_params с аудиофильской обработкой */
 static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
-				      struct snd_pcm_hw_params *params,
-				      struct snd_soc_dai *dai)
+          struct snd_pcm_hw_params *params,
+          struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	struct snd_dmaengine_dai_dma_data *dma_data;
-	struct clk *mclk;
-	int ret = 0;
-	unsigned int val = 0;
-	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
-	bool s2mono = i2s_tdm->s2mono;
-
-	dma_data = snd_soc_dai_get_dma_data(dai, substream);
-	dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
-
-			// original
-		if(0) {
-			if (i2s_tdm->mclk_calibrate)
-				rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
-								params_rate(params));
-
-			ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
-			if (ret)
-				goto err;
-		}
-			//  
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    struct snd_dmaengine_dai_dma_data *dma_data;
+    struct clk *mclk;
+    int ret = 0;
+    unsigned int val = 0;
+    unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
+
+    dma_data = snd_soc_dai_get_dma_data(dai, substream);
+    dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
+
+    /* Обновляем параметры аудиофильского процессора */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        rockchip_audiophile_set_format(i2s_tdm, params);
+    }
+
+    if (i2s_tdm->is_master_mode) {
+        if (i2s_tdm->mclk_calibrate)
+            rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+                            params_rate(params));
 //+++
-	if (i2s_tdm->is_master_mode) {
-		mclk = i2s_tdm->mclk_tx;		// !must check if RX
-
-		if( params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ) s2mono = 1;
-		if( i2s_tdm->tdm_mode != true ) {
-			if( params_format(params) == SNDRV_PCM_FORMAT_S16_LE ) {
-				div_lrck = 32; i2s_tdm->frame_width = 32;
-				//s2mono = 0;
-			} else if( s2mono ) {
-				div_lrck = 32; i2s_tdm->frame_width = 32;
-			} else {
-				div_lrck = 64; i2s_tdm->frame_width = 64;
-			} 
-		}
-
-		if( !i2s_tdm->mclk_external ){
-			//err = clk_set_rate(mclk, DEFAULT_MCLK_FS * params_rate(params));
-			if( params_rate(params) % 44100 )
-				ret = clk_set_rate(mclk, 512 * 48000);
-			else
-				ret = clk_set_rate(mclk, 512 * 44100);
-			if (ret)
-				goto err;
-		}
-
-
-		if( i2s_tdm->mclk_external ){
-			if( i2s_tdm->mclk_ext_mux ) {
-				if( params_rate(params) % 44100 ) {
-					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
-				}
-				else {
-					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
-				}
-			}
-		}
+        if( i2s_tdm->mclk_external ){
+            mclk = i2s_tdm->mclk_tx;
+            if( i2s_tdm->mclk_ext_mux ) {
+                if( params_rate(params) % 44100 ) {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
+                }
+                else {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
+                }
+            }
+        }
+        else {
+            ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+            if (ret)
+                goto err;
+        }
 //+++
 
-		mclk_rate = clk_get_rate(mclk);
-		//--bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
-		bclk_rate = i2s_tdm->frame_width * params_rate(params);
-		if (!bclk_rate) {
-			ret = -EINVAL;
-			goto err;
-		}
-		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
-		div_lrck = bclk_rate / params_rate(params);
-	}
+        mclk_rate = clk_get_rate(mclk);
+        bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+        if (!bclk_rate) {
+            ret = -EINVAL;
+            goto err;
+        }
+
+        div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+        div_lrck = bclk_rate / params_rate(params);
+    }
+
+    switch (params_format(params)) {
+    case SNDRV_PCM_FORMAT_S8:
+        val |= I2S_TXCR_VDW(8);
+        break;
+    case SNDRV_PCM_FORMAT_S16_LE:
+        val |= I2S_TXCR_VDW(16);
+        break;
+    case SNDRV_PCM_FORMAT_S20_3LE:
+        val |= I2S_TXCR_VDW(20);
+        break;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        val |= I2S_TXCR_VDW(24);
+        break;
+    case SNDRV_PCM_FORMAT_S32_LE:
+    case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+        val |= I2S_TXCR_VDW(32);
+        break;
+    default:
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
+    if (ret < 0)
+        goto err;
+
+    val |= ret;
+
+    if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
+        return 0;
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_params_trcm(substream, dai, div_bclk, div_lrck, val);
+    else
+        rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
 
-//+++
-	if( s2mono && (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) ) {
-		val |= I2S_TXCR_VDW(16);
-		val |= I2S_CHN_4;
-		goto s2mono_l;
-	}
-//+++
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S8:
-		val |= I2S_TXCR_VDW(8);
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		val |= I2S_TXCR_VDW(16);
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		val |= I2S_TXCR_VDW(20);
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		val |= I2S_TXCR_VDW(24);
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
-		val |= I2S_TXCR_VDW(32);
-		break;
-	default:
-		ret = -EINVAL;
-		goto err;
-	}
-
-//+++
-	switch (params_channels(params)) {
-	case 8:
-		val |= I2S_CHN_8;
-		break;
-	case 6:
-		val |= I2S_CHN_6;
-		break;
-	case 4:
-		val |= I2S_CHN_4;
-		break;
-	case 2:
-		val |= I2S_CHN_2;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-s2mono_l:
-
-			// only TX
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_TXM(div_bclk));
-		//---
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk));
-		//---
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_TSD_MASK,
-				   I2S_CKR_TSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   val);
-
-//+++
-
-	// orig
-	if(0) {
-		ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
-		if (ret < 0)
-			goto err;
-
-		val |= ret;
-		if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
-			return 0;
-
-		if (i2s_tdm->clk_trcm)
-			rockchip_i2s_tdm_params_trcm(substream, dai, div_bclk, div_lrck, val);
-		else
-			rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
-	}
-	// orig
-
-	ret = rockchip_i2s_io_multiplex(substream, dai);
+    ret = rockchip_i2s_io_multiplex(substream, dai);
 
 err:
-	return ret;
+    return ret;
 }
 
+/* Обновленная trigger функция */
 static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
-				    int cmd, struct snd_soc_dai *dai)
+        int cmd, struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int ret = 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int ret = 0;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
-		break;
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    /* Сбросить состояние паузы при старте */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_RESUME:
+    /* При системном resume сбрасываем pause состояние */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    /* Возобновление после паузы */
+    rockchip_i2s_tdm_resume(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_STOP:
+    /* При остановке сбрасываем состояние паузы */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+    /* Приостановка потока */
+    rockchip_i2s_tdm_pause(i2s_tdm, substream->stream);
+    break;
+    default:
+    ret = -EINVAL;
+    break;
+    }
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
-				       unsigned int freq, int dir)
+           unsigned int freq, int dir)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
 
-	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
-	if (i2s_tdm->clk_trcm) {
-		i2s_tdm->mclk_tx_freq = freq;
-		i2s_tdm->mclk_rx_freq = freq;
-	} else {
-		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-			i2s_tdm->mclk_tx_freq = freq;
-		else
-			i2s_tdm->mclk_rx_freq = freq;
-	}
+    /* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+    if (i2s_tdm->clk_trcm) {
+    i2s_tdm->mclk_tx_freq = freq;
+    i2s_tdm->mclk_rx_freq = freq;
+    } else {
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->mclk_tx_freq = freq;
+    else
+        i2s_tdm->mclk_rx_freq = freq;
+    }
 
-	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
-		stream ? "rx" : "tx", freq);
+    dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
+    stream ? "rx" : "tx", freq);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,
-						  struct snd_ctl_elem_info *uinfo)
+          struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = CLK_PPM_MIN;
-	uinfo->value.integer.max = CLK_PPM_MAX;
-	uinfo->value.integer.step = 1;
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = CLK_PPM_MIN;
+    uinfo->value.integer.max = CLK_PPM_MAX;
+    uinfo->value.integer.step = 1;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
+    ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	int ret = 0, ppm = 0;
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret = 0, ppm = 0;
 
-	if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
-	    (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
-		return -EINVAL;
+    if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
+        (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
+    return -EINVAL;
 
-	ppm = ucontrol->value.integer.value[0];
+    ppm = ucontrol->value.integer.value[0];
 
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
-					    i2s_tdm->mclk_root0_freq, ppm);
-	if (ret)
-		return ret;
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
+            i2s_tdm->mclk_root0_freq, ppm);
+    if (ret)
+    return ret;
 
-	if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
-		return 0;
+    if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
+    return 0;
 
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
-					    i2s_tdm->mclk_root1_freq, ppm);
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
+            i2s_tdm->mclk_root1_freq, ppm);
 
-	return ret;
+    return ret;
 }
 
 static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	.name = "PCM Clk Compensation In PPM",
-	.info = rockchip_i2s_tdm_clk_compensation_info,
-	.get = rockchip_i2s_tdm_clk_compensation_get,
-	.put = rockchip_i2s_tdm_clk_compensation_put,
+    .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+    .name = "PCM Clk Compensation In PPM",
+    .info = rockchip_i2s_tdm_clk_compensation_info,
+    .get = rockchip_i2s_tdm_clk_compensation_get,
+    .put = rockchip_i2s_tdm_clk_compensation_put,
 };
 
 /* loopback mode select */
 enum {
-	LOOPBACK_MODE_DIS = 0,
-	LOOPBACK_MODE_1,
-	LOOPBACK_MODE_2,
-	LOOPBACK_MODE_2_SWAP,
+    LOOPBACK_MODE_DIS = 0,
+    LOOPBACK_MODE_1,
+    LOOPBACK_MODE_2,
+    LOOPBACK_MODE_2_SWAP,
 };
 
 static const char *const loopback_text[] = {
-	"Disabled",
-	"Mode1",
-	"Mode2",
-	"Mode2 Swap",
+    "Disabled",
+    "Mode1",
+    "Mode2",
+    "Mode2 Swap",
 };
 
 static SOC_ENUM_SINGLE_EXT_DECL(loopback_mode, loopback_text);
 
 static int rockchip_i2s_tdm_loopback_get(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int reg = 0, mode = 0;
-
-	pm_runtime_get_sync(component->dev);
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &reg);
-	pm_runtime_put(component->dev);
-
-	switch (reg & I2S_XFER_LP_MODE_MASK) {
-	case I2S_XFER_LP_MODE_2_SWAP:
-		mode = LOOPBACK_MODE_2_SWAP;
-		break;
-	case I2S_XFER_LP_MODE_2:
-		mode = LOOPBACK_MODE_2;
-		break;
-	case I2S_XFER_LP_MODE_1:
-		mode = LOOPBACK_MODE_1;
-		break;
-	default:
-		mode = LOOPBACK_MODE_DIS;
-		break;
-	}
+    struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
+    unsigned int reg = 0, mode = 0;
+
+    pm_runtime_get_sync(component->dev);
+    regmap_read(i2s_tdm->regmap, I2S_XFER, &reg);
+    pm_runtime_put(component->dev);
+
+    switch (reg & I2S_XFER_LP_MODE_MASK) {
+    case I2S_XFER_LP_MODE_2_SWAP:
+    mode = LOOPBACK_MODE_2_SWAP;
+    break;
+    case I2S_XFER_LP_MODE_2:
+    mode = LOOPBACK_MODE_2;
+    break;
+    case I2S_XFER_LP_MODE_1:
+    mode = LOOPBACK_MODE_1;
+    break;
+    default:
+    mode = LOOPBACK_MODE_DIS;
+    break;
+    }
 
-	ucontrol->value.enumerated.item[0] = mode;
+    ucontrol->value.enumerated.item[0] = mode;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_loopback_put(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int val = 0, mode = ucontrol->value.enumerated.item[0];
-
-	if (mode < LOOPBACK_MODE_DIS ||
-	    mode > LOOPBACK_MODE_2_SWAP)
-		return -EINVAL;
-
-	switch (mode) {
-	case LOOPBACK_MODE_2_SWAP:
-		val = I2S_XFER_LP_MODE_2_SWAP;
-		break;
-	case LOOPBACK_MODE_2:
-		val = I2S_XFER_LP_MODE_2;
-		break;
-	case LOOPBACK_MODE_1:
-		val = I2S_XFER_LP_MODE_1;
-		break;
-	default:
-		val = I2S_XFER_LP_MODE_DIS;
-		break;
-	}
-
-	pm_runtime_get_sync(component->dev);
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, I2S_XFER_LP_MODE_MASK, val);
-	pm_runtime_put(component->dev);
+    struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
+    unsigned int val = 0, mode = ucontrol->value.enumerated.item[0];
+
+    if (mode < LOOPBACK_MODE_DIS ||
+        mode > LOOPBACK_MODE_2_SWAP)
+    return -EINVAL;
+
+    switch (mode) {
+    case LOOPBACK_MODE_2_SWAP:
+    val = I2S_XFER_LP_MODE_2_SWAP;
+    break;
+    case LOOPBACK_MODE_2:
+    val = I2S_XFER_LP_MODE_2;
+    break;
+    case LOOPBACK_MODE_1:
+    val = I2S_XFER_LP_MODE_1;
+    break;
+    default:
+    val = I2S_XFER_LP_MODE_DIS;
+    break;
+    }
+
+    pm_runtime_get_sync(component->dev);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER, I2S_XFER_LP_MODE_MASK, val);
+    pm_runtime_put(component->dev);
 
-	return 0;
+    return 0;
 }
 
 static const struct snd_kcontrol_new rockchip_i2s_tdm_snd_controls[] = {
-	SOC_ENUM_EXT("I2STDM Digital Loopback Mode", loopback_mode,
-		     rockchip_i2s_tdm_loopback_get,
-		     rockchip_i2s_tdm_loopback_put),
+    SOC_ENUM_EXT("I2STDM Digital Loopback Mode", loopback_mode,
+         rockchip_i2s_tdm_loopback_get,
+         rockchip_i2s_tdm_loopback_put),
+};
+
+/* Аудиофильские ALSA контролы */
+static int rockchip_i2s_tdm_volume_info(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_volume_get(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    ucontrol->value.integer.value[0] = i2s_tdm->volume;
+    return 0;
+}
+
+/* Обновленная функция установки громкости */
+static int rockchip_i2s_tdm_volume_put(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int volume = ucontrol->value.integer.value[0];
+    int old_volume = i2s_tdm->volume;
+    int old_linear = 0, new_linear = 0;
+    int ratio_x1000 = 0; /* Соотношение * 1000 для избежания float */
+
+    if (volume < 0 || volume > 100)
+        return -EINVAL;
+
+    if (volume == old_volume)
+        return 0;
+
+    /* Сохраняем старое значение для сравнения */
+    if (i2s_tdm->audio_proc) {
+        old_linear = i2s_tdm->audio_proc->volume_linear_q16;
+    }
+
+    i2s_tdm->volume = volume;
+    
+    /* Обновляем аудиофильскую обработку */
+    rockchip_audiophile_update_volume(i2s_tdm);
+    
+    /* Получаем новое значение */
+    if (i2s_tdm->audio_proc) {
+        new_linear = i2s_tdm->audio_proc->volume_linear_q16;
+    }
+    
+    /* Вычисляем соотношение без float */
+    if (old_linear > 0 && new_linear > 0) {
+        ratio_x1000 = (new_linear * 1000) / old_linear;
+    }
+    
+    /* Детальная информация о переходе */
+    dev_info(i2s_tdm->dev, "Volume: %d%% -> %d%% | Linear: 0x%x (%d) -> 0x%x (%d) | Ratio x1000: %d\n", 
+             old_volume, volume, 
+             old_linear, old_linear, 
+             new_linear, new_linear,
+             ratio_x1000);
+    
+    /* Проверка на большие скачки (соотношение меньше 0.5 или больше 2.0) */
+    if (old_linear > 0 && new_linear > 0) {
+        if (ratio_x1000 < 500 || ratio_x1000 > 2000) {
+            dev_warn(i2s_tdm->dev, "WARNING: Large volume jump detected! Ratio x1000: %d\n", ratio_x1000);
+        }
+    }
+    
+    return 1;
+}
+
+static int rockchip_i2s_tdm_mute_info(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    /* Инвертировать значение для плеера: mute=false -> возвращаем 1 (unmute) */
+    ucontrol->value.integer.value[0] = !i2s_tdm->mute;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    bool mute_request = ucontrol->value.integer.value[0];
+    
+    /* Инвертировать логику: pleer передает 1=unmute, 0=mute */
+    bool mute = !mute_request;
+
+    if (i2s_tdm->mute == mute)
+        return 0;
+
+    i2s_tdm->mute = mute;
+
+    if (mute) {
+        /* Включить mute мгновенно */
+        if (i2s_tdm->mute_gpio)
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Mute enabled by user control\n");
+        
+        /* Простое отключение DMA если поток активен */
+        if (is_stream_active(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK))
+            rockchip_i2s_tdm_dma_ctrl(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK, 0);
+    } else {
+        /* Выключить mute с минимальной задержкой */
+        if (i2s_tdm->mute_gpio) {
+            msleep(50);  /* Минимальная задержка */
+            gpiod_set_value(i2s_tdm->mute_gpio, 0);
+        }
+        dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Mute disabled by user control\n");
+        
+        /* Простое включение DMA если поток активен */
+        if (is_stream_active(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK))
+            rockchip_i2s_tdm_dma_ctrl(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK, 1);
+    }
+
+    return 1; /* Вернуть 1 для уведомления ALSA об изменении */
+}
+
+/* Контрол дизеринга */
+static int rockchip_i2s_tdm_dither_info(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_dither_get(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    
+    if (i2s_tdm->audio_proc)
+        ucontrol->value.integer.value[0] = i2s_tdm->audio_proc->dither_enabled;
+    else
+        ucontrol->value.integer.value[0] = 0;
+    
+    return 0;
+}
+
+static int rockchip_i2s_tdm_dither_put(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    bool dither_enable = !!ucontrol->value.integer.value[0];
+    unsigned long flags;
+    
+    if (!i2s_tdm->audio_proc)
+        return -ENODEV;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    if (i2s_tdm->audio_proc->dither_enabled != dither_enable) {
+        i2s_tdm->audio_proc->dither_enabled = dither_enable;
+        /* Обновляем состояние PRNG */
+        if (dither_enable) {
+            get_random_bytes(i2s_tdm->audio_proc->dither_state, 
+                           sizeof(i2s_tdm->audio_proc->dither_state));
+        }
+        spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+        
+        dev_info(i2s_tdm->dev, "Audiophile: Dithering %s\n", 
+                 dither_enable ? "enabled" : "disabled");
+        return 1;
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    return 0;
+}
+
+/* Контрол отображения уровня громкости в dB */
+static int rockchip_i2s_tdm_volume_db_info(struct snd_kcontrol *kcontrol,
+                                          struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = -9600;  // -96.00 dB * 100
+    uinfo->value.integer.max = 0;      // 0.00 dB * 100
+    uinfo->value.integer.step = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_volume_db_get(struct snd_kcontrol *kcontrol,
+                                         struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    
+    if (i2s_tdm->audio_proc) {
+        /* Возвращаем dB * 100 для точности */
+        ucontrol->value.integer.value[0] = 
+            (long)(i2s_tdm->audio_proc->volume_db_q8 * 100) >> 8;
+    } else {
+        ucontrol->value.integer.value[0] = 0;
+    }
+    
+    return 0;
+}
+
+/* Контрол статистики обработки */
+static int rockchip_i2s_tdm_stats_info(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER64;
+    uinfo->count = 3; // samples_processed, peak_level, clipping_detected
+    return 0;
+}
+
+static int rockchip_i2s_tdm_stats_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    unsigned long flags;
+    
+    if (!i2s_tdm->audio_proc) {
+        memset(ucontrol->value.integer64.value, 0, sizeof(long long) * 3);
+        return 0;
+    }
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    ucontrol->value.integer64.value[0] = i2s_tdm->audio_proc->samples_processed;
+    ucontrol->value.integer64.value[1] = i2s_tdm->audio_proc->peak_level;
+    ucontrol->value.integer64.value[2] = i2s_tdm->audio_proc->clipping_detected ? 1 : 0;
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    return 0;
+}
+
+/* Основные ALSA контролы */
+static struct snd_kcontrol_new rockchip_i2s_tdm_volume_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Volume",
+    .info = rockchip_i2s_tdm_volume_info,
+    .get = rockchip_i2s_tdm_volume_get,
+    .put = rockchip_i2s_tdm_volume_put,
+};
+
+static struct snd_kcontrol_new rockchip_i2s_tdm_mute_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Switch",
+    .info = rockchip_i2s_tdm_mute_info,
+    .get = rockchip_i2s_tdm_mute_get,
+    .put = rockchip_i2s_tdm_mute_put,
+};
+
+/* Дополнительные аудиофильские контролы */
+static struct snd_kcontrol_new rockchip_i2s_tdm_audiophile_controls[] = {
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "Audiophile Dithering",
+        .info = rockchip_i2s_tdm_dither_info,
+        .get = rockchip_i2s_tdm_dither_get,
+        .put = rockchip_i2s_tdm_dither_put,
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "Volume Level dB",
+        .access = SNDRV_CTL_ELEM_ACCESS_READ,
+        .info = rockchip_i2s_tdm_volume_db_info,
+        .get = rockchip_i2s_tdm_volume_db_get,
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,  
+        .name = "Audiophile Statistics",
+        .access = SNDRV_CTL_ELEM_ACCESS_READ,
+        .info = rockchip_i2s_tdm_stats_info,
+        .get = rockchip_i2s_tdm_stats_get,
+    },
+};
+
+/* PCM copy callback для обработки аудио данных */
+static int rockchip_i2s_tdm_pcm_copy_user(struct snd_soc_component *component,
+                                          struct snd_pcm_substream *substream,
+                                          int channel, unsigned long pos,
+                                          void __user *buf, unsigned long bytes)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    void *dma_area;
+    int ret;
+    static int copy_call_count = 0;
+    static bool bypass_processing = false; /* Для тестирования без обработки */
+    
+    /* Получаем наш драйвер через компонент */
+    i2s_tdm = snd_soc_component_get_drvdata(component);
+    if (!i2s_tdm) {
+        /* Отладочное сообщение только для первых вызовов */
+        if (copy_call_count < 3) {
+            dev_warn(component->dev, "Failed to get I2S TDM device from component (call %d)\n", copy_call_count++);
+        }
+        /* Fallback: стандартное копирование без обработки */
+        dma_area = substream->runtime->dma_area + pos;
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            return copy_from_user(dma_area, buf, bytes) ? -EFAULT : 0;
+        } else {
+            return copy_to_user(buf, dma_area, bytes) ? -EFAULT : 0;
+        }
+    }
+    
+    /* Получаем указатель на DMA буфер */
+    dma_area = substream->runtime->dma_area + pos;
+    if (!dma_area) {
+        dev_err(component->dev, "Invalid DMA area\n");
+        return -EINVAL;
+    }
+    
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        /* PLAYBACK: копируем от пользователя и обрабатываем */
+        if (copy_from_user(dma_area, buf, bytes))
+            return -EFAULT;
+        
+        /* Отладочное сообщение только для первых вызовов */
+        if (copy_call_count < 3) {
+            dev_info(i2s_tdm->dev, "PCM copy: %lu bytes, processor: %s, bypass: %s (call %d)\n", 
+                     bytes, 
+                     i2s_tdm->audio_proc ? "READY" : "NOT_READY",
+                     bypass_processing ? "YES" : "NO",
+                     copy_call_count++);
+        } else if (copy_call_count == 3) {
+            dev_info(i2s_tdm->dev, "PCM copy working, suppressing further debug messages\n");
+            copy_call_count++;
+        }
+        
+        /* Применяем аудиофильскую обработку только если процессор инициализирован и bypass отключен */
+        if (i2s_tdm->audio_proc && !bypass_processing && 
+            (i2s_tdm->volume != 100 || i2s_tdm->mute)) {
+            ret = rockchip_audiophile_process_buffer(i2s_tdm, dma_area, bytes);
+            if (ret < 0) {
+                dev_warn_ratelimited(i2s_tdm->dev, "Audio processing failed: %d\n", ret);
+                /* Не возвращаем ошибку, продолжаем без обработки */
+            }
+        }
+        
+        dev_dbg(i2s_tdm->dev, "Processed %lu bytes for playback\n", bytes);
+    } else {
+        /* CAPTURE: просто копируем к пользователю */
+        if (copy_to_user(buf, dma_area, bytes))
+            return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/* Добавить поддержку pause/resume в PCM hardware */
+static const struct snd_pcm_hardware rockchip_i2s_tdm_pcm_hardware = {
+    .info = SNDRV_PCM_INFO_MMAP |
+    SNDRV_PCM_INFO_MMAP_VALID |
+    SNDRV_PCM_INFO_INTERLEAVED |
+    SNDRV_PCM_INFO_PAUSE |        /* Поддержка pause */
+    SNDRV_PCM_INFO_RESUME |       /* Поддержка resume */
+    SNDRV_PCM_INFO_BLOCK_TRANSFER,
+    .formats = SNDRV_PCM_FMTBIT_S8 |
+       SNDRV_PCM_FMTBIT_S16_LE |
+       SNDRV_PCM_FMTBIT_S20_3LE |
+       SNDRV_PCM_FMTBIT_S24_LE |
+       SNDRV_PCM_FMTBIT_S32_LE,
+    .rates = SNDRV_PCM_RATE_8000_384000,
+    .rate_min = 8000,
+    .rate_max = 384000,
+    .channels_min = 2,
+    .channels_max = 16,
+    .buffer_bytes_max = 512 * 1024,
+    .period_bytes_min = 64,
+    .period_bytes_max = 64 * 1024,
+    .periods_min = 2,
+    .periods_max = 512,
+    .fifo_size = 16,
+};
+
+static const struct snd_dmaengine_pcm_config rockchip_i2s_tdm_dmaengine_pcm_config = {
+    .pcm_hardware = &rockchip_i2s_tdm_pcm_hardware,
+    .prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+    .prealloc_buffer_size = 512 * 1024,
+};
+
+/* Компонент probe функция для установки driver data */
+static int rockchip_i2s_tdm_component_probe(struct snd_soc_component *component)
+{
+    struct device *dev = component->dev;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    
+    /* Получаем наш драйвер из platform device */
+    i2s_tdm = dev_get_drvdata(dev);
+    if (!i2s_tdm) {
+        dev_err(dev, "Failed to get I2S TDM device data in component probe\n");
+        return -ENODEV;
+    }
+    
+    /* Устанавливаем driver data для компонента */
+    snd_soc_component_set_drvdata(component, i2s_tdm);
+    
+    dev_info(dev, "Audiophile component probe: driver data set successfully\n");
+    
+    return 0;
+}
+
+/* Альтернативный способ через ioctl для старых версий ALSA */
+static int rockchip_i2s_tdm_pcm_ioctl(struct snd_soc_component *component,
+                                      struct snd_pcm_substream *substream,
+                                      unsigned int cmd, void *arg)
+{
+    /* Стандартный ioctl без дополнительной обработки */
+    return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+/* Компонент с поддержкой copy callbacks */
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component_with_copy = {
+    .name = DRV_NAME,
+    .probe = rockchip_i2s_tdm_component_probe,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
+    .copy_user = rockchip_i2s_tdm_pcm_copy_user,
+    .ioctl = rockchip_i2s_tdm_pcm_ioctl,
 };
 
+/* Обновленная функция probe с инициализацией аудиофильских функций */
 static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret;
 
-	dai->capture_dma_data = &i2s_tdm->capture_dma_data;
-	dai->playback_dma_data = &i2s_tdm->playback_dma_data;
+    dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+    dai->playback_dma_data = &i2s_tdm->playback_dma_data;
 
-	if (i2s_tdm->mclk_calibrate)
-		snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+    /* Инициализируем аудиофильскую обработку */
+    ret = rockchip_audiophile_init(i2s_tdm);
+    if (ret) {
+        dev_err(i2s_tdm->dev, "Failed to initialize audiophile processor: %d\n", ret);
+        return ret;
+    }
+    
+    /* Инициализируем громкость */
+    rockchip_audiophile_update_volume(i2s_tdm);
+    dev_info(i2s_tdm->dev, "Audiophile processing enabled with copy callbacks\n");
+
+    if (i2s_tdm->mclk_calibrate) {
+        ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+        if (ret)
+            dev_err(i2s_tdm->dev, "Failed to add compensation control: %d\n", ret);
+    }
+
+    /* Основные контролы */
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_volume_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add volume control: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Audiophile volume control added successfully\n");
+
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_mute_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add mute control: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Audiophile mute control added successfully\n");
+
+    /* Аудиофильские контролы */
+    ret = snd_soc_add_dai_controls(dai, rockchip_i2s_tdm_audiophile_controls,
+                                  ARRAY_SIZE(rockchip_i2s_tdm_audiophile_controls));
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add audiophile controls: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Audiophile controls added successfully\n");
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
-				 unsigned int tx_mask, unsigned int rx_mask,
-				 int slots, int slot_width)
+     unsigned int tx_mask, unsigned int rx_mask,
+     int slots, int slot_width)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	unsigned int mask, val;
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    unsigned int mask, val;
 
-	i2s_tdm->tdm_mode = true;
-	i2s_tdm->bclk_fs = slots * slot_width;
-	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
-	val = TDM_SLOT_BIT_WIDTH(slot_width) |
-	      TDM_FRAME_WIDTH(slots * slot_width);
-	pm_runtime_get_sync(dai->dev);
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-			   mask, val);
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-			   mask, val);
-	pm_runtime_put(dai->dev);
+    i2s_tdm->tdm_mode = true;
+    i2s_tdm->bclk_fs = slots * slot_width;
+    mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+    val = TDM_SLOT_BIT_WIDTH(slot_width) |
+          TDM_FRAME_WIDTH(slots * slot_width);
+
+    pm_runtime_get_sync(dai->dev);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, val);
+    pm_runtime_put(dai->dev);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_startup(struct snd_pcm_substream *substream,
-				    struct snd_soc_dai *dai)
+        struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	if (i2s_tdm->substreams[substream->stream])
-		return -EBUSY;
+    if (i2s_tdm->substreams[substream->stream])
+    return -EBUSY;
 
-	i2s_tdm->substreams[substream->stream] = substream;
+    i2s_tdm->substreams[substream->stream] = substream;
 
-	return 0;
+    return 0;
 }
 
 static void rockchip_i2s_tdm_shutdown(struct snd_pcm_substream *substream,
-				      struct snd_soc_dai *dai)
+          struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	i2s_tdm->substreams[substream->stream] = NULL;
+    i2s_tdm->substreams[substream->stream] = NULL;
 }
 
 static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
-	.startup = rockchip_i2s_tdm_startup,
-	.shutdown = rockchip_i2s_tdm_shutdown,
-	.hw_params = rockchip_i2s_tdm_hw_params,
-	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
-	.set_fmt = rockchip_i2s_tdm_set_fmt,
-	.set_tdm_slot = rockchip_dai_tdm_slot,
-	.trigger = rockchip_i2s_tdm_trigger,
+    .startup = rockchip_i2s_tdm_startup,
+    .shutdown = rockchip_i2s_tdm_shutdown,
+    .hw_params = rockchip_i2s_tdm_hw_params,
+    .set_sysclk = rockchip_i2s_tdm_set_sysclk,
+    .set_fmt = rockchip_i2s_tdm_set_fmt,
+    .set_tdm_slot = rockchip_dai_tdm_slot,
+    .trigger = rockchip_i2s_tdm_trigger,
 };
 
 static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
-	.name = DRV_NAME,
-	.controls = rockchip_i2s_tdm_snd_controls,
-	.num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
+    .name = DRV_NAME,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
 };
 
 static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_TXFIFOLR:
-	case I2S_INTSR:
-	case I2S_RXFIFOLR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_TXFIFOLR:
+    case I2S_INTSR:
+    case I2S_RXFIFOLR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXFIFOLR:
-	case I2S_INTCR:
-	case I2S_INTSR:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_RXFIFOLR:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXFIFOLR:
+    case I2S_INTCR:
+    case I2S_INTSR:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_RXFIFOLR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_RXDR:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_RXDR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
-	{0x00, 0x7200000f},
-	{0x04, 0x01c8000f},
-	{0x08, 0x00001f1f},
-	{0x10, 0x001f0000},
-	{0x14, 0x01f00000},
-	{0x30, 0x00003eff},
-	{0x34, 0x00003eff},
-	{0x38, 0x00000707},
+    {0x00, 0x7200000f},
+    {0x04, 0x01c8000f},
+    {0x08, 0x00001f1f},
+    {0x10, 0x001f0000},
+    {0x14, 0x01f00000},
+    {0x30, 0x00003eff},
+    {0x34, 0x00003eff},
+    {0x38, 0x00000707},
 };
 
 static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = I2S_CLKDIV,
-	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
-	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
-	.writeable_reg = rockchip_i2s_tdm_wr_reg,
-	.readable_reg = rockchip_i2s_tdm_rd_reg,
-	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
-	.precious_reg = rockchip_i2s_tdm_precious_reg,
-	.cache_type = REGCACHE_FLAT,
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = I2S_CLKDIV,
+    .reg_defaults = rockchip_i2s_tdm_reg_defaults,
+    .num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+    .writeable_reg = rockchip_i2s_tdm_wr_reg,
+    .readable_reg = rockchip_i2s_tdm_rd_reg,
+    .volatile_reg = rockchip_i2s_tdm_volatile_reg,
+    .precious_reg = rockchip_i2s_tdm_precious_reg,
+    .cache_type = REGCACHE_FLAT,
 };
 
 static int common_soc_init(struct device *dev, u32 addr)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
-	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
-	int i;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	switch (trcm) {
-	case I2S_CKR_TRCM_TXONLY:
-	case I2S_CKR_TRCM_RXONLY:
-		break;
-	default:
-		return 0;
-	}
-
-	for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
-		if (addr != configs[i].addr)
-			continue;
-		reg = configs[i].reg;
-		if (trcm == I2S_CKR_TRCM_TXONLY)
-			val = configs[i].txonly;
-		else
-			val = configs[i].rxonly;
-
-		if (reg)
-			regmap_write(i2s_tdm->grf, reg, val);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    const struct txrx_config *configs = i2s_tdm->soc_data->configs;
+    u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
+    int i;
+
+    if (IS_ERR(i2s_tdm->grf))
+    return 0;
+
+    switch (trcm) {
+    case I2S_CKR_TRCM_TXONLY:
+    case I2S_CKR_TRCM_RXONLY:
+    break;
+    default:
+    return 0;
+    }
+
+    for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
+    if (addr != configs[i].addr)
+        continue;
+    reg = configs[i].reg;
+    if (trcm == I2S_CKR_TRCM_TXONLY)
+        val = configs[i].txonly;
+    else
+        val = configs[i].rxonly;
+
+    if (reg)
+        regmap_write(i2s_tdm->grf, reg, val);
+    }
 
-	return 0;
+    return 0;
 }
 
 static const struct txrx_config px30_txrx_config[] = {
-	{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
+    { 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk1808_txrx_config[] = {
-	{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
+    { 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3308_txrx_config[] = {
-	{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
-	{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
+    { 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
+    { 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3568_txrx_config[] = {
-	{ 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
-	{ 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
-	{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
+    { 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
+    { 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
+    { 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
 };
 
 static const struct txrx_config rv1126_txrx_config[] = {
-	{ 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
+    { 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
 };
 
 static const struct rk_i2s_soc_data px30_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = px30_txrx_config,
-	.config_count = ARRAY_SIZE(px30_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = px30_txrx_config,
+    .config_count = ARRAY_SIZE(px30_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk1808_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rk1808_txrx_config,
-	.config_count = ARRAY_SIZE(rk1808_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = rk1808_txrx_config,
+    .config_count = ARRAY_SIZE(rk1808_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3308_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.grf_reg_offset = 0x0308,
-	.grf_shift = 5,
-	.configs = rk3308_txrx_config,
-	.config_count = ARRAY_SIZE(rk3308_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0400,
+    .grf_reg_offset = 0x0308,
+    .grf_shift = 5,
+    .configs = rk3308_txrx_config,
+    .config_count = ARRAY_SIZE(rk3308_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3568_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.configs = rk3568_txrx_config,
-	.config_count = ARRAY_SIZE(rk3568_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0400,
+    .configs = rk3568_txrx_config,
+    .config_count = ARRAY_SIZE(rk3568_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rv1126_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rv1126_txrx_config,
-	.config_count = ARRAY_SIZE(rv1126_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = rv1126_txrx_config,
+    .config_count = ARRAY_SIZE(rv1126_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct of_device_id rockchip_i2s_tdm_match[] = {
 #ifdef CONFIG_CPU_PX30
-	{ .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
+    { .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK1808
-	{ .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
+    { .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3308
-	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+    { .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3568
-	{ .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
+    { .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3588
-	{ .compatible = "rockchip,rk3588-i2s-tdm", },
+    { .compatible = "rockchip,rk3588-i2s-tdm", },
 #endif
 #ifdef CONFIG_CPU_RV1106
-	{ .compatible = "rockchip,rv1106-i2s-tdm", },
+    { .compatible = "rockchip,rv1106-i2s-tdm", },
 #endif
 #ifdef CONFIG_CPU_RV1126
-	{ .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
+    { .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
 #endif
-	{},
+    {},
 };
 
 #ifdef HAVE_SYNC_RESET
 static int of_i2s_resetid_get(struct device_node *node,
-			      const char *id)
+              const char *id)
 {
-	struct of_phandle_args args;
-	int index = 0;
-	int ret;
-
-	if (id)
-		index = of_property_match_string(node,
-						 "reset-names", id);
-	ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
-					 index, &args);
-	if (ret)
-		return ret;
+    struct of_phandle_args args;
+    int index = 0;
+    int ret;
+
+    if (id)
+    index = of_property_match_string(node,
+         "reset-names", id);
+    ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+         index, &args);
+    if (ret)
+    return ret;
 
-	return args.args[0];
+    return args.args[0];
 }
 #endif
 
 static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
-					struct snd_soc_dai_driver **soc_dai)
+        struct snd_soc_dai_driver **soc_dai)
 {
-	struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
-		.probe = rockchip_i2s_tdm_dai_probe,
-		.playback = {
-			.stream_name = "Playback",
-			.channels_min = 2,
-			.channels_max = 16,
-//			.rates = SNDRV_PCM_RATE_8000_192000,
-			.rates = SNDRV_PCM_RATE_KNOT,
-			.formats = (SNDRV_PCM_FMTBIT_S8 |
-				    SNDRV_PCM_FMTBIT_S16_LE |
-				    SNDRV_PCM_FMTBIT_S20_3LE |
-				    SNDRV_PCM_FMTBIT_S24_LE |
-				    SNDRV_PCM_FMTBIT_S32_LE |
-				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE) |
-					SNDRV_PCM_FMTBIT_DSD_U32_LE,
-		},
-		.capture = {
-			.stream_name = "Capture",
-			.channels_min = 2,
-			.channels_max = 16,
-//			.rates = SNDRV_PCM_RATE_8000_192000,
-			.rates = SNDRV_PCM_RATE_KNOT,
-			.formats = (SNDRV_PCM_FMTBIT_S8 |
-				    SNDRV_PCM_FMTBIT_S16_LE |
-				    SNDRV_PCM_FMTBIT_S20_3LE |
-				    SNDRV_PCM_FMTBIT_S24_LE |
-				    SNDRV_PCM_FMTBIT_S32_LE |
-				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
-		},
-		.ops = &rockchip_i2s_tdm_dai_ops,
-	};
-
-	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
-				sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
-	if (!(*soc_dai))
-		return -ENOMEM;
+    struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+    .probe = rockchip_i2s_tdm_dai_probe,
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000,
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000,
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
+    },
+    .ops = &rockchip_i2s_tdm_dai_ops,
+    };
+
+    *soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+    sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+    if (!(*soc_dai))
+    return -ENOMEM;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int num,
-				       bool is_rx_path)
+           int num,
+           bool is_rx_path)
 {
-	unsigned int *i2s_data;
-	int i, j, ret = 0;
+    unsigned int *i2s_data;
+    int i, j, ret = 0;
 
-	if (is_rx_path)
-		i2s_data = i2s_tdm->i2s_sdis;
-	else
-		i2s_data = i2s_tdm->i2s_sdos;
-
-	for (i = 0; i < num; i++) {
-		if (i2s_data[i] > CH_GRP_MAX - 1) {
-			dev_err(i2s_tdm->dev,
-				"%s path i2s_data[%d]: %d is overflow, max is: %d\n",
-				is_rx_path ? "RX" : "TX",
-				i, i2s_data[i], CH_GRP_MAX);
-			ret = -EINVAL;
-			goto err;
-		}
-
-		for (j = 0; j < num; j++) {
-			if (i == j)
-				continue;
-
-			if (i2s_data[i] == i2s_data[j]) {
-				dev_err(i2s_tdm->dev,
-					"%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
-					is_rx_path ? "RX" : "TX",
-					i, i2s_data[i],
-					j, i2s_data[j]);
-				ret = -EINVAL;
-				goto err;
-			}
-		}
-	}
+    if (is_rx_path)
+    i2s_data = i2s_tdm->i2s_sdis;
+    else
+    i2s_data = i2s_tdm->i2s_sdos;
+
+    for (i = 0; i < num; i++) {
+    if (i2s_data[i] > CH_GRP_MAX - 1) {
+        dev_err(i2s_tdm->dev,
+    "%s path i2s_data[%d]: %d is overflow, max is: %d\n",
+    is_rx_path ? "RX" : "TX",
+    i, i2s_data[i], CH_GRP_MAX);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    for (j = 0; j < num; j++) {
+        if (i == j)
+    continue;
+
+        if (i2s_data[i] == i2s_data[j]) {
+    dev_err(i2s_tdm->dev,
+        "%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
+        is_rx_path ? "RX" : "TX",
+        i, i2s_data[i],
+        j, i2s_data[j]);
+    ret = -EINVAL;
+    goto err;
+        }
+    }
+    }
 
 err:
-	return ret;
+    return ret;
 }
 
 static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_PATH_MASK(idx),
-				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_PATH_MASK(idx),
+       I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_PATH_MASK(idx),
-				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_PATH_MASK(idx),
+       I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					 int num, bool is_rx_path)
+         int num, bool is_rx_path)
 {
-	if (is_rx_path)
-		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
-	else
-		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
+    if (is_rx_path)
+    rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
+    else
+    rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
 }
 
 static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct device_node *np,
-					 bool is_rx_path)
+         struct device_node *np,
+         bool is_rx_path)
 {
-	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
-	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
-	char *i2s_path_prop;
-	unsigned int *i2s_data;
-	int num, ret = 0;
-
-	if (is_rx_path) {
-		i2s_path_prop = i2s_rx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdis;
-	} else {
-		i2s_path_prop = i2s_tx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdos;
-	}
-
-	num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
-	if (num < 0) {
-		if (num != -ENOENT) {
-			dev_err(i2s_tdm->dev,
-				"Failed to read '%s' num: %d\n",
-				i2s_path_prop, num);
-			ret = num;
-		}
-		goto out;
-	} else if (num != CH_GRP_MAX) {
-		dev_err(i2s_tdm->dev,
-			"The num: %d should be: %d\n", num, CH_GRP_MAX);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = of_property_read_u32_array(np, i2s_path_prop,
-					 i2s_data, num);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to read '%s': %d\n",
-			i2s_path_prop, ret);
-		goto out;
-	}
-
-	ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to check i2s data bus: %d\n", ret);
-		goto out;
-	}
+    char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
+    char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
+    char *i2s_path_prop;
+    unsigned int *i2s_data;
+    int num, ret = 0;
+
+    if (is_rx_path) {
+    i2s_path_prop = i2s_rx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdis;
+    } else {
+    i2s_path_prop = i2s_tx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdos;
+    }
+
+    num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
+    if (num < 0) {
+    if (num != -ENOENT) {
+        dev_err(i2s_tdm->dev,
+    "Failed to read '%s' num: %d\n",
+    i2s_path_prop, num);
+        ret = num;
+    }
+    goto out;
+    } else if (num != CH_GRP_MAX) {
+    dev_err(i2s_tdm->dev,
+        "The num: %d should be: %d\n", num, CH_GRP_MAX);
+    ret = -EINVAL;
+    goto out;
+    }
+
+    ret = of_property_read_u32_array(np, i2s_path_prop,
+         i2s_data, num);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to read '%s': %d\n",
+        i2s_path_prop, ret);
+    goto out;
+    }
+
+    ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to check i2s data bus: %d\n", ret);
+    goto out;
+    }
 
-	rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
+    rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
 
 out:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
 }
 
 static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
 }
 
-/*
 static int rockchip_i2s_tdm_get_fifo_count(struct device *dev, int stream)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int val = 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int val = 0;
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
-	else
-		regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
-
-	val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
+    else
+    regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
+
+    val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
+          ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
+          ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
+          ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
 
-	return val;
+    return val;
 }
 
 static const struct snd_dlp_config dconfig = {
-	.get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
+    .get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
 };
-*/
 
-		/* RX FIFO Overrun
 static irqreturn_t rockchip_i2s_tdm_isr(int irq, void *devid)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
-	struct snd_pcm_substream *substream;
-	u32 val;
-
-	regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
-	if (val & I2S_INTSR_TXUI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
-
-	if (val & I2S_INTSR_RXOI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "RX FIFO Overrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_CAPTURE];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
+    struct snd_pcm_substream *substream;
+    u32 val;
+
+    regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
+
+    if (val & I2S_INTSR_TXUI_ACT) {
+    dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
+    if (substream)
+        snd_pcm_stop_xrun(substream);
+    }
+
+    if (val & I2S_INTSR_RXOI_ACT) {
+    dev_warn_ratelimited(i2s_tdm->dev, "RX FIFO Overrun\n");
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+    substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_CAPTURE];
+    if (substream)
+        snd_pcm_stop_xrun(substream);
+    }
 
-	return IRQ_HANDLED;
+    return IRQ_HANDLED;
 }
-		*/
 
 static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 {
-	struct device_node *node = pdev->dev.of_node;
-	const struct of_device_id *of_id;
-	struct rk_i2s_tdm_dev *i2s_tdm;
-	struct snd_soc_dai_driver *soc_dai;
-	struct resource *res;
-	void __iomem *regs;
+    struct device_node *node = pdev->dev.of_node;
+    const struct of_device_id *of_id;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    struct snd_soc_dai_driver *soc_dai;
+    struct resource *res;
+    void __iomem *regs;
 #ifdef HAVE_SYNC_RESET
-	bool sync;
+    bool sync;
 #endif
-	int ret, val, i;//, irq;
-//+++
-	struct clk *hclk_p, *hclk_pp;
-//+++
+    int ret, val, i, irq;
 
-	ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
-	if (ret)
-		return ret;
-
-	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
-	if (!i2s_tdm)
-		return -ENOMEM;
-
-	i2s_tdm->dev = &pdev->dev;
-
-	of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
-	if (!of_id)
-		return -EINVAL;
-
-	spin_lock_init(&i2s_tdm->lock);
-	i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
-
-	for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
-		if (of_property_read_bool(node, of_quirks[i].quirk))
-			i2s_tdm->quirks |= of_quirks[i].id;
-
-	i2s_tdm->bclk_fs = 64;
-	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
-		if ((val >= 32) && (val % 2 == 0))
-			i2s_tdm->bclk_fs = val;
-	}
-
-	i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
-	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
-		if (val >= 0 && val <= 2) {
-			i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
-			if (i2s_tdm->clk_trcm)
-				soc_dai->symmetric_rates = 1;
-		}
-	}
-
-	i2s_tdm->tdm_fsync_half_frame =
-		of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
-
-	if (of_property_read_bool(node, "rockchip,playback-only"))
-		soc_dai->capture.channels_min = 0;
-	else if (of_property_read_bool(node, "rockchip,capture-only"))
-		soc_dai->playback.channels_min = 0;
+    ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+    if (ret)
+    return ret;
+
+    i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+    if (!i2s_tdm)
+    return -ENOMEM;
+
+    i2s_tdm->dev = &pdev->dev;
+    i2s_tdm->volume = 100;
+    /* Начальное состояние mute = false (звук включен) для соответствия ожиданиям плеера */
+    i2s_tdm->mute = false; 
+    
+    /* Инициализация состояния паузы */
+    i2s_tdm->playback_paused = false;
+    i2s_tdm->capture_paused = false;
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Initial volume = %d, mute = %d (sound %s)\n", 
+     i2s_tdm->volume, i2s_tdm->mute, i2s_tdm->mute ? "OFF" : "ON");
+
+    i2s_tdm->mute_gpio = devm_gpiod_get_optional(&pdev->dev, "mute", GPIOD_OUT_LOW);
+    if (IS_ERR(i2s_tdm->mute_gpio)) {
+    ret = PTR_ERR(i2s_tdm->mute_gpio);
+    dev_err(&pdev->dev, "Failed to get mute GPIO: %d\n", ret);
+    i2s_tdm->mute_gpio = NULL;
+    } else if (i2s_tdm->mute_gpio) {
+    /* Установить GPIO: mute=false -> GPIO=0 (звук включен) */
+    gpiod_set_value(i2s_tdm->mute_gpio, i2s_tdm->mute ? 1 : 0);
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: GPIO mute initialized to %d (sound %s)\n", 
+         i2s_tdm->mute ? 1 : 0, i2s_tdm->mute ? "OFF" : "ON");
+    }
+
+    of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+    if (!of_id)
+    return -EINVAL;
+
+    spin_lock_init(&i2s_tdm->lock);
+    i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
+
+    for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
+    if (of_property_read_bool(node, of_quirks[i].quirk))
+        i2s_tdm->quirks |= of_quirks[i].id;
+
+    i2s_tdm->bclk_fs = 64;
+    if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+    if ((val >= 32) && (val % 2 == 0))
+        i2s_tdm->bclk_fs = val;
+    }
+
+    i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+    if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+    if (val >= 0 && val <= 2) {
+        i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+        if (i2s_tdm->clk_trcm)
+    soc_dai->symmetric_rates = 1;
+    }
+    }
+
+    i2s_tdm->tdm_fsync_half_frame =
+    of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
+
+    if (of_property_read_bool(node, "rockchip,playback-only"))
+    soc_dai->capture.channels_min = 0;
+    else if (of_property_read_bool(node, "rockchip,capture-only"))
+    soc_dai->playback.channels_min = 0;
 
-	i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+    i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
 
 #ifdef HAVE_SYNC_RESET
-	sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
-
-	if (i2s_tdm->clk_trcm && sync) {
-		struct device_node *cru_node;
-
-		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
-		i2s_tdm->cru_base = of_iomap(cru_node, 0);
-		if (!i2s_tdm->cru_base)
-			return -ENOENT;
-
-		i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
-		i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
-	}
+    sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
+
+    if (i2s_tdm->clk_trcm && sync) {
+    struct device_node *cru_node;
+
+    cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+    i2s_tdm->cru_base = of_iomap(cru_node, 0);
+    if (!i2s_tdm->cru_base)
+        return -ENOENT;
+
+    i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+    i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+    }
 #endif
 
-	i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
-	if (IS_ERR(i2s_tdm->tx_reset)) {
-		ret = PTR_ERR(i2s_tdm->tx_reset);
-		if (ret != -ENOENT)
-			return ret;
-	}
-
-	i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
-	if (IS_ERR(i2s_tdm->rx_reset)) {
-		ret = PTR_ERR(i2s_tdm->rx_reset);
-		if (ret != -ENOENT)
-			return ret;
-	}
-
-	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
-	if (IS_ERR(i2s_tdm->hclk))
-		return PTR_ERR(i2s_tdm->hclk);
-
-	ret = clk_prepare_enable(i2s_tdm->hclk);
-	if (ret)
-		return ret;
-
-	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
-	if (IS_ERR(i2s_tdm->mclk_tx))
-		return PTR_ERR(i2s_tdm->mclk_tx);
-
-	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
-	if (IS_ERR(i2s_tdm->mclk_rx))
-		return PTR_ERR(i2s_tdm->mclk_rx);
+    i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+    if (IS_ERR(i2s_tdm->tx_reset)) {
+    ret = PTR_ERR(i2s_tdm->tx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+    if (IS_ERR(i2s_tdm->rx_reset)) {
+    ret = PTR_ERR(i2s_tdm->rx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+    if (IS_ERR(i2s_tdm->hclk))
+    return PTR_ERR(i2s_tdm->hclk);
+
+    ret = clk_prepare_enable(i2s_tdm->hclk);
+    if (ret)
+    return ret;
+
+    i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+    if (IS_ERR(i2s_tdm->mclk_tx))
+    return PTR_ERR(i2s_tdm->mclk_tx);
+
+    i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+    if (IS_ERR(i2s_tdm->mclk_rx))
+    return PTR_ERR(i2s_tdm->mclk_rx);
 
 //+++
-	//+++c
-	i2s_tdm->hclk_root_f = 0;
-	i2s_tdm->hclk_root_f =
-		of_property_read_bool(node, "my,hclk_root_f");
-
-	i2s_tdm->hclk_root_x = 0;
-	of_property_read_u32(node, "my,hclk_root_x", &i2s_tdm->hclk_root_x );
-
-	if(i2s_tdm->hclk_root_f) {
-		i2s_tdm->hclk_root = devm_clk_get(&pdev->dev, "hclk_root");
-		if(IS_ERR(i2s_tdm->hclk_root)) i2s_tdm->hclk_root_f = 0;
-	}
-
-	if (i2s_tdm->hclk_root_f) {
-		hclk_p = clk_get_parent(i2s_tdm->hclk);
-		if (!IS_ERR( hclk_p )) {
-			hclk_pp = clk_get_parent(hclk_p);
-			if (!IS_ERR( hclk_pp )) {
-				clk_set_parent( hclk_pp, i2s_tdm->hclk_root );
-			}
-		}
-	}
-	if( i2s_tdm->hclk_root_x )
-		clk_set_rate ( i2s_tdm->hclk, 44100*i2s_tdm->hclk_root_x );		// default 48000*2048 from pll0
-
-	i2s_tdm->dma_bytes = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	of_property_read_u32(node, "my,dma_bytes", &i2s_tdm->dma_bytes );
-
-	i2s_tdm->dma_burst = 8;
-	of_property_read_u32(node, "my,dma_burst", &i2s_tdm->dma_burst );
-
-	//+++c
-
-	i2s_tdm->s2mono = 0;
-	i2s_tdm->s2mono =
-		of_property_read_bool(node, "my,s2mono");
-
-	i2s_tdm->mclk_external = 0;
-	i2s_tdm->mclk_external =
-		of_property_read_bool(node, "my,mclk_external");
-
-	if (i2s_tdm->mclk_external) {
-		i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
-		if (IS_ERR(i2s_tdm->mclk_ext)) {
-			return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
-					     "Failed to get clock mclk_ext\n");
-		}
-		else {
-			i2s_tdm->mclk_ext_mux = 0;
-			i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
-			if (!IS_ERR(i2s_tdm->clk_44)) {
-				i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
-				if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
-			}
-		}
-	}
-
-	i2s_tdm->dcount = 0;
-
+    i2s_tdm->mclk_external = 0;
+    i2s_tdm->mclk_external =
+    of_property_read_bool(node, "my,mclk_external");
+    if (i2s_tdm->mclk_external) {
+    i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
+    if (IS_ERR(i2s_tdm->mclk_ext)) {
+        return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
+             "Failed to get clock mclk_ext\n");
+    }
+    else {
+        i2s_tdm->mclk_ext_mux = 0;
+        i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
+        if (!IS_ERR(i2s_tdm->clk_44)) {
+    i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
+    if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
+        }
+    }
+    }
 //+++
 
-	i2s_tdm->io_multiplex =
-		of_property_read_bool(node, "rockchip,io-multiplex");
+    i2s_tdm->io_multiplex =
+    of_property_read_bool(node, "rockchip,io-multiplex");
+
+    i2s_tdm->mclk_calibrate =
+    of_property_read_bool(node, "rockchip,mclk-calibrate");
 
-	i2s_tdm->mclk_calibrate = 0;
-		//of_property_read_bool(node, "rockchip,mclk-calibrate");
-	if (i2s_tdm->mclk_calibrate) {
-		i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
-		if (IS_ERR(i2s_tdm->mclk_tx_src))
-			return PTR_ERR(i2s_tdm->mclk_tx_src);
-
-		i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
-		if (IS_ERR(i2s_tdm->mclk_rx_src))
-			return PTR_ERR(i2s_tdm->mclk_rx_src);
-
-		i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
-		if (IS_ERR(i2s_tdm->mclk_root0))
-			return PTR_ERR(i2s_tdm->mclk_root0);
-
-		i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
-		if (IS_ERR(i2s_tdm->mclk_root1))
-			return PTR_ERR(i2s_tdm->mclk_root1);
-
-		i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
-		i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
-		i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
-	}
-
-	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
-
-	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-						&rockchip_i2s_tdm_regmap_config);
-	if (IS_ERR(i2s_tdm->regmap))
-		return PTR_ERR(i2s_tdm->regmap);
-
-		/* RX FIFO Overrun
-	irq = platform_get_irq_optional(pdev, 0);
-	if (irq > 0) {
-		ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
-				       IRQF_SHARED, node->name, i2s_tdm);
-		if (ret) {
-			dev_err(&pdev->dev, "failed to request irq %u\n", irq);
-			return ret;
-		}
-	}
-		*/
-
-	i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
-	i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
-
-	i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
-	i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
-
-	ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
-		return ret;
-	}
-
-	ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
-		return ret;
-	}
-
-	atomic_set(&i2s_tdm->refcount, 0);
-	dev_set_drvdata(&pdev->dev, i2s_tdm);
-
-	pm_runtime_enable(&pdev->dev);
-	if (!pm_runtime_enabled(&pdev->dev)) {
-		ret = i2s_tdm_runtime_resume(&pdev->dev);
-		if (ret)
-			goto err_pm_disable;
-	}
-
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
-		unsigned int rate = DEFAULT_FS * DEFAULT_MCLK_FS;
-		unsigned int div_bclk = DEFAULT_FS * DEFAULT_MCLK_FS;
-		unsigned int div_lrck = i2s_tdm->bclk_fs;
-
-		div_bclk = DIV_ROUND_CLOSEST(rate, div_lrck * DEFAULT_FS);
-
-		/* assign generic freq */
-		clk_set_rate(i2s_tdm->mclk_rx, rate);
-		clk_set_rate(i2s_tdm->mclk_tx, rate);
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
-				   I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
-
-		if (i2s_tdm->clk_trcm)
-			rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
-		else
-			rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-
-		pm_runtime_forbid(&pdev->dev);
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
-			   I2S_DMACR_TDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
-			   I2S_DMACR_RDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
-
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
-		i2s_tdm->soc_data->init(&pdev->dev, res->start);
-
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &rockchip_i2s_tdm_component,
-					      soc_dai, 1);
-
-	if (ret) {
-		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_suspend;
-	}
-
-	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
-		return ret;
-
-	/*
-	if (of_property_read_bool(node, "rockchip,digital-loopback"))
-		ret = devm_snd_dmaengine_dlp_register(&pdev->dev, &dconfig);
-	else
-	*/
-		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
-
-	if (ret) {
-		dev_err(&pdev->dev, "Could not register PCM\n");
-		return ret;
-	}
+    if (i2s_tdm->mclk_calibrate) {
+    i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+    if (IS_ERR(i2s_tdm->mclk_tx_src))
+        return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+    i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+    if (IS_ERR(i2s_tdm->mclk_rx_src))
+        return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+    i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+    if (IS_ERR(i2s_tdm->mclk_root0))
+        return PTR_ERR(i2s_tdm->mclk_root0);
+
+    i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+    if (IS_ERR(i2s_tdm->mclk_root1))
+        return PTR_ERR(i2s_tdm->mclk_root1);
+
+    i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
+    i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
+    i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
+    i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
+    }
+
+    regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+    if (IS_ERR(regs))
+    return PTR_ERR(regs);
+
+    i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+        &rockchip_i2s_tdm_regmap_config);
+    if (IS_ERR(i2s_tdm->regmap))
+    return PTR_ERR(i2s_tdm->regmap);
+
+    irq = platform_get_irq_optional(pdev, 0);
+    if (irq > 0) {
+    ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
+           IRQF_SHARED, node->name, i2s_tdm);
+    if (ret) {
+        dev_err(&pdev->dev, "failed to request irq %u\n", irq);
+        return ret;
+    }
+    }
+
+    i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+    i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+    i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
+    return ret;
+    }
+
+    ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
+    return ret;
+    }
+
+    atomic_set(&i2s_tdm->refcount, 0);
+    dev_set_drvdata(&pdev->dev, i2s_tdm);
+    pm_runtime_enable(&pdev->dev);
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Pause/Resume support enabled\n");
+
+    if (!pm_runtime_enabled(&pdev->dev)) {
+    ret = i2s_tdm_runtime_resume(&pdev->dev);
+    if (ret)
+        goto err_pm_disable;
+    }
+
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
+    unsigned int rate = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_bclk = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_lrck = i2s_tdm->bclk_fs;
+
+    div_bclk = DIV_ROUND_CLOSEST(rate, div_lrck * DEFAULT_FS);
+
+    /* assign generic freq */
+    clk_set_rate(i2s_tdm->mclk_rx, rate);
+    clk_set_rate(i2s_tdm->mclk_tx, rate);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
+       I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+        rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+
+    pm_runtime_forbid(&pdev->dev);
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+           I2S_DMACR_TDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+           I2S_DMACR_RDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+    if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
+    i2s_tdm->soc_data->init(&pdev->dev, res->start);
+
+    /* Пробуем зарегистрировать компонент с поддержкой аудиофильской обработки */
+    ret = devm_snd_soc_register_component(&pdev->dev,
+              &rockchip_i2s_tdm_component_with_copy,
+              soc_dai, 1);
+
+    if (ret) {
+    dev_warn(&pdev->dev, "Failed to register component with copy support: %d\n", ret);
+    dev_info(&pdev->dev, "Falling back to standard component (no volume processing)\n");
+    
+    /* Fallback на стандартный компонент */
+    ret = devm_snd_soc_register_component(&pdev->dev,
+                  &rockchip_i2s_tdm_component,
+                  soc_dai, 1);
+    if (ret) {
+        dev_err(&pdev->dev, "Could not register DAI\n");
+        goto err_suspend;
+    }
+    } else {
+    dev_info(&pdev->dev, "Audiophile component registered successfully with copy callbacks\n");
+    }
+
+    if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+    return ret;
+
+    if (of_property_read_bool(node, "rockchip,digital-loopback"))
+    ret = devm_snd_dmaengine_dlp_register(&pdev->dev, &dconfig);
+    else
+    /* Использовать кастомную конфигурацию с поддержкой pause/resume */
+    ret = devm_snd_dmaengine_pcm_register(&pdev->dev, 
+             &rockchip_i2s_tdm_dmaengine_pcm_config, 
+             0);
+    if (ret) {
+    dev_err(&pdev->dev, "Could not register PCM\n");
+    return ret;
+    }
 
-	return 0;
+    return 0;
 
 err_suspend:
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
 err_pm_disable:
-	pm_runtime_disable(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	pm_runtime_disable(&pdev->dev);
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
 
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
-	clk_disable_unprepare(i2s_tdm->hclk);
+    clk_disable_unprepare(i2s_tdm->mclk_tx);
+    clk_disable_unprepare(i2s_tdm->mclk_rx);
+    clk_disable_unprepare(i2s_tdm->hclk);
 
-	return 0;
+    return 0;
 }
 
 static void rockchip_i2s_tdm_platform_shutdown(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	pm_runtime_get_sync(i2s_tdm->dev);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
-	pm_runtime_put(i2s_tdm->dev);
+    pm_runtime_get_sync(i2s_tdm->dev);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
+    pm_runtime_put(i2s_tdm->dev);
 }
 
 #ifdef CONFIG_PM_SLEEP
 static int rockchip_i2s_tdm_suspend(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 
-	regcache_mark_dirty(i2s_tdm->regmap);
+    regcache_mark_dirty(i2s_tdm->regmap);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_resume(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int ret;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
 
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
-		return ret;
-	ret = regcache_sync(i2s_tdm->regmap);
-	pm_runtime_put(dev);
+    ret = pm_runtime_get_sync(dev);
+    if (ret < 0)
+    return ret;
 
-	return ret;
+    ret = regcache_sync(i2s_tdm->regmap);
+
+    pm_runtime_put(dev);
+
+    return ret;
 }
 #endif
 
 static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
-	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
-			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
-				rockchip_i2s_tdm_resume)
+    SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+           NULL)
+    SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+    rockchip_i2s_tdm_resume)
 };
 
 static struct platform_driver rockchip_i2s_tdm_driver = {
-	.probe = rockchip_i2s_tdm_probe,
-	.remove = rockchip_i2s_tdm_remove,
-	.shutdown = rockchip_i2s_tdm_platform_shutdown,
-	.driver = {
-		.name = DRV_NAME,
-		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
-		.pm = &rockchip_i2s_tdm_pm_ops,
-	},
+    .probe = rockchip_i2s_tdm_probe,
+    .remove = rockchip_i2s_tdm_remove,
+    .shutdown = rockchip_i2s_tdm_platform_shutdown,
+    .driver = {
+    .name = DRV_NAME,
+    .of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+    .pm = &rockchip_i2s_tdm_pm_ops,
+    },
 };
+
 module_platform_driver(rockchip_i2s_tdm_driver);
 
-MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
+MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface with Fixed-Point Audiophile Enhancement");
 MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
\ No newline at end of file
