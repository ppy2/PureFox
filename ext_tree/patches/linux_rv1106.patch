diff -Naur original_dir/arch/arm/boot/dts/Makefile modified_dir/arch/arm/boot/dts/Makefile
--- original_dir/arch/arm/boot/dts/Makefile	2025-03-12 14:48:17.000000000 +0300
+++ modified_dir/arch/arm/boot/dts/Makefile	2025-07-28 13:41:22.584099345 +0300
@@ -971,7 +971,10 @@
 	r8a7794-silk.dtb \
 	r9a06g032-rzn1d400-db.dtb \
 	sh73a0-kzm9g.dtb 
-# dtb-$(CONFIG_ARCH_ROCKCHIP) += \
+dtb-$(CONFIG_ARCH_ROCKCHIP) += \
+	rv1106_ext.dtb \
+        rv1106_512_ext.dtb \
+        rv1106_pll.dtb
 #	rv1103g-38x38-ipc-v10.dtb \
 #	rv1103g-battery-ipc-v10.dtb \
 #	rv1103g-battery-ipc-v11.dtb \
diff -Naur original_dir/sound/soc/codecs/dummy-codec.c modified_dir/sound/soc/codecs/dummy-codec.c
--- original_dir/sound/soc/codecs/dummy-codec.c	2025-03-12 14:48:17.000000000 +0300
+++ modified_dir/sound/soc/codecs/dummy-codec.c	2025-08-03 09:10:43.767581277 +0300
@@ -50,21 +50,29 @@
 		.stream_name = "Dummy Playback",
 		.channels_min = 2,
 		.channels_max = 384,
-		.rates = SNDRV_PCM_RATE_8000_384000,
+		.rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 8000,
+		.rate_max = 22579200,  /* DSD512 support */
 		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
 			    SNDRV_PCM_FMTBIT_S20_3LE |
 			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
+			    SNDRV_PCM_FMTBIT_S32_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U16_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U32_LE),
 	},
 	.capture = {
 		.stream_name = "Dummy Capture",
 		.channels_min = 2,
 		.channels_max = 384,
-		.rates = SNDRV_PCM_RATE_8000_384000,
+		.rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 8000,
+		.rate_max = 22579200,  /* DSD512 support */
 		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
 			    SNDRV_PCM_FMTBIT_S20_3LE |
 			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
+			    SNDRV_PCM_FMTBIT_S32_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U16_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U32_LE),
 	},
 	.ops = &dummy_codec_dai_ops,
 };
diff -Naur original_dir/sound/soc/rockchip/rockchip_i2s_tdm.c modified_dir/sound/soc/rockchip/rockchip_i2s_tdm.c
--- original_dir/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-03-12 14:48:17.000000000 +0300
+++ modified_dir/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-08-12 20:29:40.434956200 +0300
@@ -1,21 +1,19 @@
 /* sound/soc/rockchip/rockchip_i2s_tdm.c
  *
  * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ * Enhanced with Audiophile Processing (Fixed for Buildroot)
  *
  * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
  * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Audiophile Enhancement: 2025
  */
-
 #include <linux/module.h>
 #include <linux/mfd/syscon.h>
 #include <linux/delay.h>
 #include <linux/of_gpio.h>
 #include <linux/of_device.h>
 #include <linux/of_address.h>
+#include <linux/gpio/consumer.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/clk/rockchip.h>
@@ -23,15 +21,28 @@
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/random.h>
+#include <linux/math64.h>
+#include <linux/version.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
 
-#include "rockchip_i2s_tdm.h"
-//#include "rockchip_dlp.h"
+/* Conditional NEON compilation */
+#ifdef CONFIG_KERNEL_MODE_NEON
+#include <linux/kernel.h>
+#include <asm/neon.h>
+#include <asm/simd.h>
+/* Disable NEON intrinsics for soft-float ABI */
+#if defined(__ARM_NEON__) && !defined(__SOFTFP__)
+#include <arm_neon.h>
+#define HAVE_NEON_SUPPORT
+#endif
+#endif
 
-//+++
-//#define DBGOUT(msg...)		do { printk(msg); } while (0)
-//+++
+#include "rockchip_i2s_tdm.h"
+#include "rockchip_dlp.h"
 
 #define DRV_NAME "rockchip-i2s-tdm"
 
@@ -47,320 +58,1191 @@
 #define CLK_PPM_MAX				(1000)
 #define MAXBURST_PER_FIFO			8
 
+/* Auto-mute timing defaults */
+#define DEFAULT_PREMUTE_DELAY_MS		50
+#define DEFAULT_POSTMUTE_DELAY_MS		450
+#define AUTOMUTE_DEBOUNCE_MS			1000
+
 #define QUIRK_ALWAYS_ON				BIT(0)
 #define QUIRK_HDMI_PATH				BIT(1)
+#define QUIRK_MCLK_ALWAYS_ON			BIT(2)
+
+/* Structure for audiophile processing (simplified version) */
+struct rk_audiophile_processor {
+    /* Logarithmic volume coefficients (fixed point) */
+    int32_t volume_linear_q16;    // Q15.16 fixed point (0-65536)
+    int32_t volume_db_q8;         // Q23.8 fixed point (-96*256 - 0)
+    
+    /* Dithering */
+    uint32_t dither_state[4];     // PRNG state for dithering
+    bool dither_enabled;          // Is dithering enabled
+    
+    /* Format parameters */
+    unsigned int sample_rate;
+    unsigned int channels;
+    unsigned int bit_depth;
+    snd_pcm_format_t format;
+    
+    /* Statistics and metrics */
+    uint64_t samples_processed;
+    uint32_t peak_level;          // Peak level
+    bool clipping_detected;       // Clipping detection
+};
 
 struct txrx_config {
-	u32 addr;
-	u32 reg;
-	u32 txonly;
-	u32 rxonly;
+    u32 addr;
+    u32 reg;
+    u32 txonly;
+    u32 rxonly;
 };
 
 struct rk_i2s_soc_data {
-	u32 softrst_offset;
-	u32 grf_reg_offset;
-	u32 grf_shift;
-	int config_count;
-	const struct txrx_config *configs;
-	int (*init)(struct device *dev, u32 addr);
+    u32 softrst_offset;
+    u32 grf_reg_offset;
+    u32 grf_shift;
+    int config_count;
+    const struct txrx_config *configs;
+    int (*init)(struct device *dev, u32 addr);
 };
 
 struct rk_i2s_tdm_dev {
-	struct device *dev;
-	struct clk *hclk;
-	struct clk *mclk_tx;
-	struct clk *mclk_rx;
-	/* The mclk_tx_src is parent of mclk_tx */
-	struct clk *mclk_tx_src;
-	/* The mclk_rx_src is parent of mclk_rx */
-	struct clk *mclk_rx_src;
-	/*
-	 * The mclk_root0 and mclk_root1 are root parent and supplies for
-	 * the different FS.
-	 *
-	 * e.g:
-	 * mclk_root0 is VPLL0, used for FS=48000Hz
-	 * mclk_root0 is VPLL1, used for FS=44100Hz
-	 */
-	struct clk *mclk_root0;
-	struct clk *mclk_root1;
+    struct device *dev;
+    struct clk *hclk;
+    struct clk *mclk_tx;
+    struct clk *mclk_rx;
+    /* The mclk_tx_src is parent of mclk_tx */
+    struct clk *mclk_tx_src;
+    /* The mclk_rx_src is parent of mclk_rx */
+    struct clk *mclk_rx_src;
+    /*
+     * The mclk_root0 and mclk_root1 are root parent and supplies for
+     * the different FS.
+     */
+    struct clk *mclk_root0;
+    struct clk *mclk_root1;
 //+++
-	//+++c
-	struct clk *hclk_root;
-	bool hclk_root_f;
-	unsigned int hclk_root_x;
-	unsigned int dma_burst, dma_bytes;
-	//+++c
-	bool mclk_external;
-	bool mclk_ext_mux;
-	bool s2mono;
-	struct clk *mclk_ext;
-	struct clk *clk_44;
-	struct clk *clk_48;
-	int dcount;
-	unsigned int frame_width;
+    bool mclk_external;
+    bool mclk_ext_mux;
+    struct clk *mclk_ext;
+    struct clk *clk_44;
+    struct clk *clk_48;
 //+++
-	struct regmap *regmap;
-	struct regmap *grf;
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-	struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
-	struct reset_control *tx_reset;
-	struct reset_control *rx_reset;
-	const struct rk_i2s_soc_data *soc_data;
+    struct regmap *regmap;
+    struct regmap *grf;
+    struct snd_dmaengine_dai_dma_data capture_dma_data;
+    struct snd_dmaengine_dai_dma_data playback_dma_data;
+    struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
+    struct reset_control *tx_reset;
+    struct reset_control *rx_reset;
+    const struct rk_i2s_soc_data *soc_data;
 #ifdef HAVE_SYNC_RESET
-	void __iomem *cru_base;
-	int tx_reset_id;
-	int rx_reset_id;
-#endif
-	bool is_master_mode;
-	bool io_multiplex;
-	bool mclk_calibrate;
-	bool tdm_mode;
-	bool tdm_fsync_half_frame;
-	unsigned int mclk_rx_freq;
-	unsigned int mclk_tx_freq;
-	unsigned int mclk_root0_freq;
-	unsigned int mclk_root1_freq;
-	unsigned int mclk_root0_initial_freq;
-	unsigned int mclk_root1_initial_freq;
-	unsigned int bclk_fs;
-	unsigned int clk_trcm;
-	unsigned int i2s_sdis[CH_GRP_MAX];
-	unsigned int i2s_sdos[CH_GRP_MAX];
-	unsigned int quirks;
-	int clk_ppm;
-	atomic_t refcount;
-	spinlock_t lock; /* xfer lock */
+    void __iomem *cru_base;
+    int tx_reset_id;
+    int rx_reset_id;
+#endif
+    bool is_master_mode;
+    bool io_multiplex;
+    bool mclk_calibrate;
+    bool tdm_mode;
+    bool tdm_fsync_half_frame;
+    unsigned int mclk_rx_freq;
+    unsigned int mclk_tx_freq;
+    unsigned int mclk_root0_freq;
+    unsigned int mclk_root1_freq;
+    unsigned int mclk_root0_initial_freq;
+    unsigned int mclk_root1_initial_freq;
+    unsigned int bclk_fs;
+    unsigned int clk_trcm;
+    unsigned int i2s_sdis[CH_GRP_MAX];
+    unsigned int i2s_sdos[CH_GRP_MAX];
+    unsigned int quirks;
+    int clk_ppm;
+    atomic_t refcount;
+    spinlock_t lock; /* xfer lock */
+    int volume;
+    bool mute;
+    struct gpio_desc *mute_gpio;
+    
+    /* MCLK multiplier for switching 512/1024 */
+    int mclk_multiplier;            // MCLK multiplier: 512 or 1024
+    
+    /* Automatic mute during switching */
+    bool auto_mute_active;          // Active state of automatic mute
+    bool user_mute_priority;        // User priority over automation
+    struct delayed_work mute_pre_work;    // Timer to enable mute 20ms before
+    struct delayed_work mute_post_work;   // Timer to disable mute after 400ms
+    struct mutex mute_lock;         // Mutex for protecting mute operations
+    
+    /* Audiophile processor */
+    struct rk_audiophile_processor *audio_proc;
+    spinlock_t audio_proc_lock;   // Protection for real-time processing
+    
+    /* Add pause state */
+    bool playback_paused;
+    bool capture_paused;
+    
+    /* Debounce for auto-mute */
+    unsigned long last_auto_mute_time;
+    
+    /* Configurable auto-mute times via sysfs */
+    unsigned int premute_delay_ms;      // Delay between mute and stop/start (default 50ms)
+    unsigned int postmute_delay_ms;     // Mute hold time after start (default 450ms)
+    
+    /* GPIO for DSD-on signal */
+    struct gpio_desc *dsd_on_gpio;
+    bool dsd_mode_active;
+    
+    /* DSD sample swap to eliminate purple noise */
+    bool dsd_sample_swap;
+    
+    /* Channel swap controls */
+    bool pcm_channel_swap;     /* PCM: LRCK inversion */
+    bool dsd_physical_swap;    /* DSD: swap pins A6/A3 */
+    
+    /* ALSA control for sysfs and alsamixer synchronization */
+    struct snd_kcontrol *mute_kcontrol;
+    struct snd_soc_dai *dai; /* For ALSA card access */
+    
+    /* Saved format for forced changes application */
+    unsigned int format;
 };
 
+/* Forward declarations for auto-mute functions */
+static void rockchip_i2s_tdm_apply_mute(struct rk_i2s_tdm_dev *i2s_tdm, bool enable);
+static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm, int num);
+
+
+
+/* DSD physical channel swap function (I2S routing) */
+static void rockchip_i2s_tdm_apply_dsd_physical_swap(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    /* Change I2S TX routing for DSD physical swap
+     * Standard configuration: i2s_sdos[0]=2, i2s_sdos[1]=3, i2s_sdos[2]=0, i2s_sdos[3]=1
+     * Swap configuration: exchange i2s_sdos[1] and i2s_sdos[3] (channels A6/A3)
+     * IMPORTANT: swap applies only in DSD mode!
+     */
+    
+    
+    if (i2s_tdm->dsd_physical_swap && i2s_tdm->dsd_mode_active) {
+        /* Check if swap needs to be applied - only if routing is standard [2,3,0,1] */
+        if (i2s_tdm->i2s_sdos[2] == 0 && i2s_tdm->i2s_sdos[3] == 1) {
+            /* Swap: exchange channels 2 and 3 (A6/A3) */
+            unsigned int temp = i2s_tdm->i2s_sdos[2];
+            i2s_tdm->i2s_sdos[2] = i2s_tdm->i2s_sdos[3];
+            i2s_tdm->i2s_sdos[3] = temp;
+            
+            
+            /* Apply new routing */
+            rockchip_i2s_tdm_tx_path_config(i2s_tdm, 4);
+        }
+    } else {
+        /* Check if standard routing needs to be restored - only if current is swap [2,3,1,0] */
+        if (i2s_tdm->i2s_sdos[2] == 1 && i2s_tdm->i2s_sdos[3] == 0) {
+            /* Restore standard configuration: 2,3,0,1 */
+            i2s_tdm->i2s_sdos[0] = 2;
+            i2s_tdm->i2s_sdos[1] = 3;
+            i2s_tdm->i2s_sdos[2] = 0;
+            i2s_tdm->i2s_sdos[3] = 1;
+            
+            
+            /* Apply standard routing */
+            rockchip_i2s_tdm_tx_path_config(i2s_tdm, 4);
+        }
+    }
+}
+
+/* DSD format detection */
+static inline int is_dsd(snd_pcm_format_t format)
+{
+    switch (format) {
+        case SNDRV_PCM_FORMAT_DSD_U8:
+        case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        case SNDRV_PCM_FORMAT_DSD_U16_BE:
+        case SNDRV_PCM_FORMAT_DSD_U32_LE:
+        case SNDRV_PCM_FORMAT_DSD_U32_BE:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+/* Calculate proper BCLK frequency for DSD formats */
+static unsigned int calculate_dsd_bclk(snd_pcm_format_t format, unsigned int sample_rate)
+{
+    /* CORRECT BCLK frequencies for DSD (determine by sample_rate):
+     * DSD64: BCLK = 2.8224 MHz 
+     * DSD128: BCLK = 5.6448 MHz  
+     * DSD256: BCLK = 11.2896 MHz
+     * DSD512: BCLK = 22.5792 MHz
+     */
+    
+    /* Determine DSD type by sample_rate */
+    if (sample_rate <= 88200) {
+        return 2822400;  /* DSD64: 2.8224 MHz - CORRECT! */
+    } else if (sample_rate <= 176400) {
+        return 5644800;  /* DSD128: 5.6448 MHz */
+    } else if (sample_rate <= 352800) {
+        return 11289600; /* DSD256: 11.2896 MHz */
+    } else {
+        return 22579200; /* DSD512: 22.5792 MHz */
+    }
+}
+
+static void rockchip_i2s_tdm_trigger_auto_mute(struct rk_i2s_tdm_dev *i2s_tdm);
+static void rockchip_i2s_tdm_trigger_stop_mute(struct rk_i2s_tdm_dev *i2s_tdm);
+static void rockchip_i2s_tdm_mute_pre_work(struct work_struct *work);
+static void rockchip_i2s_tdm_mute_post_work(struct work_struct *work);
+
 static struct i2s_of_quirks {
-	char *quirk;
-	int id;
+    char *quirk;
+    int id;
 } of_quirks[] = {
-	{
-		.quirk = "rockchip,always-on",
-		.id = QUIRK_ALWAYS_ON,
-	},
-	{
-		.quirk = "rockchip,hdmi-path",
-		.id = QUIRK_HDMI_PATH,
-	},
+    {
+    .quirk = "rockchip,always-on",
+    .id = QUIRK_ALWAYS_ON,
+    },
+    {
+    .quirk = "rockchip,hdmi-path",
+    .id = QUIRK_HDMI_PATH,
+    },
+    {
+    .quirk = "rockchip,mclk-always-on",
+    .id = QUIRK_MCLK_ALWAYS_ON,
+    },
+};
+
+/* Simple LINEAR table for testing smoothness */
+/* Each percent = 655 units (65536/100) */
+static const int32_t volume_linear_table[101] = {
+    0,     655,   1310,  1965,  2621,  3276,  3931,  4586,  5242,  5897,   // 0-9%
+    6552,  7207,  7863,  8518,  9173,  9828,  10484, 11139, 11794, 12449, // 10-19%
+    13105, 13760, 14415, 15070, 15726, 16381, 17036, 17691, 18347, 19002, // 20-29%
+    19657, 20312, 20968, 21623, 22278, 22933, 23589, 24244, 24899, 25554, // 30-39%
+    26210, 26865, 27520, 28175, 28831, 29486, 30141, 30796, 31452, 32107, // 40-49%
+    32762, 33417, 34073, 34728, 35383, 36038, 36694, 37349, 38004, 38659, // 50-59%
+    39315, 39970, 40625, 41280, 41936, 42591, 43246, 43901, 44557, 45212, // 60-69%
+    45867, 46522, 47178, 47833, 48488, 49143, 49799, 50454, 51109, 51764, // 70-79%
+    52420, 53075, 53730, 54385, 55041, 55696, 56351, 57006, 57662, 58317, // 80-89%
+    58972, 59627, 60283, 60938, 61593, 62248, 62904, 63559, 64214, 64869, // 90-99%
+    65536  // 100% = 1.0 in Q15.16
+};
+
+/* Simplified dB table - not used yet */
+static const int32_t volume_db_table[101] = {
+    -15360, -2048, -1792, -1600, -1458, -1344, -1248, -1168, -1098, -1038, // 0-9%
+    -984,  -936,  -892,  -852,  -816,  -782,  -750,  -720,  -692,  -666,  // 10-19%
+    -640,  -616,  -594,  -572,  -552,  -532,  -514,  -496,  -478,  -462,  // 20-29%
+    -446,  -430,  -416,  -402,  -388,  -374,  -362,  -350,  -338,  -326,  // 30-39%
+    -316,  -306,  -296,  -286,  -276,  -268,  -260,  -252,  -244,  -236,  // 40-49%
+    -228,  -222,  -216,  -210,  -204,  -198,  -192,  -186,  -182,  -178,  // 50-59%
+    -174,  -170,  -166,  -162,  -158,  -154,  -150,  -146,  -142,  -138,  // 60-69%
+    -134,  -130,  -126,  -122,  -118,  -114,  -110,  -106,  -102,  -98,   // 70-79%
+    -94,   -90,   -86,   -82,   -78,   -74,   -70,   -66,   -62,   -58,   // 80-89%
+    -54,   -50,   -46,   -42,   -38,   -34,   -30,   -26,   -22,   -18,   // 90-99%
+    0      // 100% = 0dB
 };
 
+/* Improved 32-bit LFSR for dithering with maximum period */
+static inline uint32_t simple_lfsr(uint32_t *state)
+{
+    uint32_t bit = ((*state >> 0) ^ (*state >> 2) ^ (*state >> 3) ^ (*state >> 5)) & 1;
+    *state = (*state >> 1) | (bit << 31);
+    return *state;
+}
+
+/* TPDF dithering generation with fixed point */
+static inline int32_t generate_dither_tpdf(struct rk_audiophile_processor *proc, int bit_depth)
+{
+    uint32_t rand1 = simple_lfsr(&proc->dither_state[0]);
+    uint32_t rand2 = simple_lfsr(&proc->dither_state[1]);
+    
+    /* Correct TPDF: use 16-bit values to avoid overflow */
+    int32_t dither = (int32_t)((rand1 & 0xFFFF) + (rand2 & 0xFFFF)) - 65536;
+    
+    /* Scale for appropriate bit depth */
+    switch (bit_depth) {
+        case 16: return dither >> 16;       // 1 LSB for 16-bit
+        case 24: return dither >> 8;        // 1 LSB for 24-bit  
+        case 32: return dither;             // 1 LSB for 32-bit
+        default: return dither >> 16;
+    }
+}
+
+/* Maximally optimized 16-bit stereo processing */
+static void process_stereo_16bit_fixed(struct rk_audiophile_processor *proc,
+                                      int16_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    const bool dither_enabled = proc->dither_enabled;
+    size_t i;
+    int32_t left, right;
+    bool clipping_detected = false;
+    
+    if (dither_enabled) {
+        /* Path with dithering - generate dithering for stereo pair */
+        for (i = 0; i < frames; i++) {
+            /* Generate dithering for stereo pair simultaneously */
+            uint32_t rand1 = simple_lfsr(&proc->dither_state[0]);
+            uint32_t rand2 = simple_lfsr(&proc->dither_state[1]);
+            int32_t dither_base = (int32_t)((rand1 & 0xFFFF) + (rand2 & 0xFFFF)) - 65536;
+            int32_t dither_l = dither_base >> 16;
+            int32_t dither_r = (dither_base + 1) >> 16; // Slightly different for channels
+            
+            /* Process both channels */
+            left = ((int32_t)buffer[i * 2] * volume) >> 16;
+            right = ((int32_t)buffer[i * 2 + 1] * volume) >> 16;
+            
+            left += dither_l;
+            right += dither_r;
+            
+            /* Fast clipping without detailed tracking */
+            left = (left > 32767) ? 32767 : (left < -32768) ? -32768 : left;
+            right = (right > 32767) ? 32767 : (right < -32768) ? -32768 : right;
+            
+            buffer[i * 2] = (int16_t)left;
+            buffer[i * 2 + 1] = (int16_t)right;
+        }
+    } else {
+        /* Fast path without dithering */
+        for (i = 0; i < frames; i++) {
+            /* Process both channels */
+            left = ((int32_t)buffer[i * 2] * volume) >> 16;
+            right = ((int32_t)buffer[i * 2 + 1] * volume) >> 16;
+            
+            /* Check clipping only if needed */
+            if (unlikely(left > 32767 || left < -32768 || right > 32767 || right < -32768)) {
+                clipping_detected = true;
+                left = (left > 32767) ? 32767 : (left < -32768) ? -32768 : left;
+                right = (right > 32767) ? 32767 : (right < -32768) ? -32768 : right;
+            }
+            
+            buffer[i * 2] = (int16_t)left;
+            buffer[i * 2 + 1] = (int16_t)right;
+        }
+    }
+    
+    /* Update statistics in batches */
+    proc->samples_processed += frames * 2;
+    if (clipping_detected) {
+        proc->clipping_detected = true;
+    }
+}
+
+
+
+/* Maximally optimized 32-bit stereo processing */
+static void process_stereo_32bit_fixed(struct rk_audiophile_processor *proc,
+                                      int32_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    const bool dither_enabled = proc->dither_enabled;
+    size_t i;
+    int64_t left, right;
+    bool clipping_detected = false;
+    
+    if (dither_enabled) {
+        /* Path with dithering */
+        for (i = 0; i < frames; i++) {
+            int32_t dither_l = generate_dither_tpdf(proc, 32);
+            int32_t dither_r = generate_dither_tpdf(proc, 32);
+            
+            /* Process both channels */
+            left = ((int64_t)buffer[i * 2] * volume) >> 16;
+            right = ((int64_t)buffer[i * 2 + 1] * volume) >> 16;
+            
+            left += dither_l;
+            right += dither_r;
+            
+            /* Fast clipping without detailed tracking */
+            left = (left > 2147483647LL) ? 2147483647LL : (left < -2147483648LL) ? -2147483648LL : left;
+            right = (right > 2147483647LL) ? 2147483647LL : (right < -2147483648LL) ? -2147483648LL : right;
+            
+            buffer[i * 2] = (int32_t)left;
+            buffer[i * 2 + 1] = (int32_t)right;
+        }
+    } else {
+        /* Fast path without dithering */
+        for (i = 0; i < frames; i++) {
+            /* Process both channels */
+            left = ((int64_t)buffer[i * 2] * volume) >> 16;
+            right = ((int64_t)buffer[i * 2 + 1] * volume) >> 16;
+            
+            /* Check clipping only if needed */
+            if (unlikely(left > 2147483647LL || left < -2147483648LL || 
+                        right > 2147483647LL || right < -2147483648LL)) {
+                clipping_detected = true;
+                left = (left > 2147483647LL) ? 2147483647LL : (left < -2147483648LL) ? -2147483648LL : left;
+                right = (right > 2147483647LL) ? 2147483647LL : (right < -2147483648LL) ? -2147483648LL : right;
+            }
+            
+            buffer[i * 2] = (int32_t)left;
+            buffer[i * 2 + 1] = (int32_t)right;
+        }
+    }
+    
+    /* Update statistics in batches */
+    proc->samples_processed += frames * 2;
+    if (clipping_detected) {
+        proc->clipping_detected = true;
+    }
+}
+
+/* Optimized 24-bit stereo processing with fixed point */
+static void process_stereo_24bit_fixed(struct rk_audiophile_processor *proc,
+                                      int32_t *buffer, size_t frames)
+{
+    const int32_t volume = proc->volume_linear_q16;
+    size_t i;
+    int32_t left, right;
+    
+    const bool dither_enabled = proc->dither_enabled;
+    bool clipping_detected = false;
+    
+    if (dither_enabled) {
+        /* Path with dithering */
+        for (i = 0; i < frames; i++) {
+            int32_t dither_l = generate_dither_tpdf(proc, 24);
+            int32_t dither_r = generate_dither_tpdf(proc, 24);
+            
+            /* Sign extension and multiplication in one expression */
+            left = (((buffer[i * 2] << 8) >> 8) * volume) >> 16;
+            right = (((buffer[i * 2 + 1] << 8) >> 8) * volume) >> 16;
+            
+            left += dither_l;
+            right += dither_r;
+            
+            /* Fast clipping without detailed tracking */
+            left = (left > 8388607) ? 8388607 : (left < -8388608) ? -8388608 : left;
+            right = (right > 8388607) ? 8388607 : (right < -8388608) ? -8388608 : right;
+            
+            buffer[i * 2] = left & 0xFFFFFF00;
+            buffer[i * 2 + 1] = right & 0xFFFFFF00;
+        }
+    } else {
+        /* Fast path without dithering */
+        for (i = 0; i < frames; i++) {
+            /* Sign extension and multiplication in one expression */
+            left = (((buffer[i * 2] << 8) >> 8) * volume) >> 16;
+            right = (((buffer[i * 2 + 1] << 8) >> 8) * volume) >> 16;
+            
+            /* Check clipping only if needed */
+            if (unlikely(left > 8388607 || left < -8388608 || right > 8388607 || right < -8388608)) {
+                clipping_detected = true;
+                left = (left > 8388607) ? 8388607 : (left < -8388608) ? -8388608 : left;
+                right = (right > 8388607) ? 8388607 : (right < -8388608) ? -8388608 : right;
+            }
+            
+            buffer[i * 2] = left & 0xFFFFFF00;
+            buffer[i * 2 + 1] = right & 0xFFFFFF00;
+        }
+    }
+    
+    /* Update statistics in batches */
+    proc->samples_processed += frames * 2;
+    if (clipping_detected) {
+        proc->clipping_detected = true;
+    }
+}
+
+#ifdef HAVE_NEON_SUPPORT
+/* Maximally optimized NEON version for 16-bit stereo */
+static void process_stereo_16bit_neon(struct rk_audiophile_processor *proc,
+                                     int16_t *buffer, size_t frames)
+{
+    if (may_use_simd()) {
+        kernel_neon_begin();
+        
+        const int32_t volume = proc->volume_linear_q16;
+        size_t neon_frames = frames & ~3; // Process 4 frames at a time
+        size_t i;
+        
+        /* NEON optimized loop: 4 stereo frames at a time */
+        for (i = 0; i < neon_frames; i += 4) {
+            /* Load 8 int16 values (4 stereo frames) */
+            int16x8_t samples = vld1q_s16(&buffer[i * 2]);
+            
+            /* Convert to 32-bit for multiplication */
+            int32x4_t left = vmovl_s16(vget_low_s16(samples));
+            int32x4_t right = vmovl_s16(vget_high_s16(samples));
+            
+            /* Apply volume */
+            left = vshrq_n_s32(vmulq_n_s32(left, volume), 16);
+            right = vshrq_n_s32(vmulq_n_s32(right, volume), 16);
+            
+            /* Add dithering if enabled */
+            if (proc->dither_enabled) {
+                /* Simple dithering for NEON */
+                int32x4_t dither_l = vdupq_n_s32(generate_dither_tpdf(proc, 16));
+                int32x4_t dither_r = vdupq_n_s32(generate_dither_tpdf(proc, 16));
+                left = vaddq_s32(left, dither_l);
+                right = vaddq_s32(right, dither_r);
+            }
+            
+            /* Limit and convert back to 16-bit */
+            int16x4_t left_16 = vqmovn_s32(left);
+            int16x4_t right_16 = vqmovn_s32(right);
+            
+            /* Save result */
+            vst1q_s16(&buffer[i * 2], vcombine_s16(left_16, right_16));
+        }
+        
+        /* Process remainder the usual way */
+        for (; i < frames; i++) {
+            int32_t left = (int32_t)buffer[i * 2];
+            int32_t right = (int32_t)buffer[i * 2 + 1];
+            
+            left = (left * volume) >> 16;
+            right = (right * volume) >> 16;
+            
+            if (proc->dither_enabled) {
+                left += generate_dither_tpdf(proc, 16);
+                right += generate_dither_tpdf(proc, 16);
+            }
+            
+            left = (left > 32767) ? 32767 : (left < -32768) ? -32768 : left;
+            right = (right > 32767) ? 32767 : (right < -32768) ? -32768 : right;
+            
+            buffer[i * 2] = (int16_t)left;
+            buffer[i * 2 + 1] = (int16_t)right;
+        }
+        
+        kernel_neon_end();
+    } else {
+        /* Fallback to normal processing */
+        process_stereo_16bit_fixed(proc, buffer, frames);
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+
+/* NEON version for 24-bit stereo */
+static void process_stereo_24bit_neon(struct rk_audiophile_processor *proc,
+                                     int32_t *buffer, size_t frames)
+{
+    if (may_use_simd()) {
+        kernel_neon_begin();
+        
+        const int32_t volume = proc->volume_linear_q16;
+        size_t neon_frames = frames & ~1; // Process 2 frames at a time
+        size_t i;
+        
+        /* NEON optimized loop: 2 stereo frames at a time */
+        for (i = 0; i < neon_frames; i += 2) {
+            /* Load 4 int32 values (2 stereo frames) */
+            int32x4_t samples = vld1q_s32(&buffer[i * 2]);
+            
+            /* Sign extension to 24-bit */
+            samples = vshlq_n_s32(vshrq_n_s32(samples, 8), 8);
+            
+            /* Apply volume */
+            int64x2_t left = vmull_n_s32(vget_low_s32(samples), volume);
+            int64x2_t right = vmull_n_s32(vget_high_s32(samples), volume);
+            
+            int32x2_t left_32 = vshrn_n_s64(left, 16);
+            int32x2_t right_32 = vshrn_n_s64(right, 16);
+            
+            /* Add dithering if enabled */
+            if (proc->dither_enabled) {
+                int32x2_t dither_l = vdup_n_s32(generate_dither_tpdf(proc, 24));
+                int32x2_t dither_r = vdup_n_s32(generate_dither_tpdf(proc, 24));
+                left_32 = vadd_s32(left_32, dither_l);
+                right_32 = vadd_s32(right_32, dither_r);
+            }
+            
+            /* Limit to 24-bit */
+            left_32 = vmin_s32(vmax_s32(left_32, vdup_n_s32(-8388608)), vdup_n_s32(8388607));
+            right_32 = vmin_s32(vmax_s32(right_32, vdup_n_s32(-8388608)), vdup_n_s32(8388607));
+            
+            /* Mask to 24-bit and save */
+            int32x4_t result = vcombine_s32(left_32, right_32);
+            result = vandq_s32(result, vdupq_n_s32(0xFFFFFF00));
+            vst1q_s32(&buffer[i * 2], result);
+        }
+        
+        /* Process remainder */
+        for (; i < frames; i++) {
+            int32_t left = (buffer[i * 2] << 8) >> 8;
+            int32_t right = (buffer[i * 2 + 1] << 8) >> 8;
+            
+            left = (left * volume) >> 16;
+            right = (right * volume) >> 16;
+            
+            if (proc->dither_enabled) {
+                left += generate_dither_tpdf(proc, 24);
+                right += generate_dither_tpdf(proc, 24);
+            }
+            
+            left = (left > 8388607) ? 8388607 : (left < -8388608) ? -8388608 : left;
+            right = (right > 8388607) ? 8388607 : (right < -8388608) ? -8388608 : right;
+            
+            buffer[i * 2] = left & 0xFFFFFF00;
+            buffer[i * 2 + 1] = right & 0xFFFFFF00;
+        }
+        
+        kernel_neon_end();
+    } else {
+        process_stereo_24bit_fixed(proc, buffer, frames);
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+
+/* NEON version for 32-bit stereo */
+static void process_stereo_32bit_neon(struct rk_audiophile_processor *proc,
+                                     int32_t *buffer, size_t frames)
+{
+    if (may_use_simd()) {
+        kernel_neon_begin();
+        
+        const int32_t volume = proc->volume_linear_q16;
+        size_t neon_frames = frames & ~1; // Process 2 frames at a time
+        size_t i;
+        
+        /* NEON optimized loop: 2 stereo frames at a time */
+        for (i = 0; i < neon_frames; i += 2) {
+            /* Load 4 int32 values (2 stereo frames) */
+            int32x4_t samples = vld1q_s32(&buffer[i * 2]);
+            
+            /* Apply volume with 64-bit precision */
+            int64x2_t left = vmull_n_s32(vget_low_s32(samples), volume);
+            int64x2_t right = vmull_n_s32(vget_high_s32(samples), volume);
+            
+            int32x2_t left_32 = vshrn_n_s64(left, 16);
+            int32x2_t right_32 = vshrn_n_s64(right, 16);
+            
+            /* Add dithering if enabled */
+            if (proc->dither_enabled) {
+                int32x2_t dither_l = vdup_n_s32(generate_dither_tpdf(proc, 32));
+                int32x2_t dither_r = vdup_n_s32(generate_dither_tpdf(proc, 32));
+                left_32 = vadd_s32(left_32, dither_l);
+                right_32 = vadd_s32(right_32, dither_r);
+            }
+            
+            /* Limit to 32-bit */
+            left_32 = vmin_s32(vmax_s32(left_32, vdup_n_s32(-2147483648)), vdup_n_s32(2147483647));
+            right_32 = vmin_s32(vmax_s32(right_32, vdup_n_s32(-2147483648)), vdup_n_s32(2147483647));
+            
+            /* Save result */
+            vst1q_s32(&buffer[i * 2], vcombine_s32(left_32, right_32));
+        }
+        
+        /* Process remainder */
+        for (; i < frames; i++) {
+            int64_t left = ((int64_t)buffer[i * 2] * volume) >> 16;
+            int64_t right = ((int64_t)buffer[i * 2 + 1] * volume) >> 16;
+            
+            if (proc->dither_enabled) {
+                left += generate_dither_tpdf(proc, 32);
+                right += generate_dither_tpdf(proc, 32);
+            }
+            
+            left = (left > 2147483647LL) ? 2147483647LL : (left < -2147483648LL) ? -2147483648LL : left;
+            right = (right > 2147483647LL) ? 2147483647LL : (right < -2147483648LL) ? -2147483648LL : right;
+            
+            buffer[i * 2] = (int32_t)left;
+            buffer[i * 2 + 1] = (int32_t)right;
+        }
+        
+        kernel_neon_end();
+    } else {
+        process_stereo_32bit_fixed(proc, buffer, frames);
+    }
+    
+    proc->samples_processed += frames * 2;
+}
+#endif
+
+/* Main audio processing function */
+static int rockchip_audiophile_process_buffer(struct rk_i2s_tdm_dev *i2s_tdm,
+                                            void *buffer, size_t buffer_size)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    size_t frame_size, frames;
+    static int call_count = 0; /* Call counter for debugging */
+    static bool debug_samples = true; /* Output first samples for debugging */
+    static bool high_rate_warning_shown = false;
+    
+    if (!proc) {
+        dev_warn_ratelimited(i2s_tdm->dev, "Audio processor not initialized\n");
+        return 0;
+    }
+    
+    /* IMPORTANT: Disable processing for DSD formats - they should pass through directly */
+    if (proc->format == SNDRV_PCM_FORMAT_DSD_U8 ||
+        proc->format == SNDRV_PCM_FORMAT_DSD_U16_LE ||
+        proc->format == SNDRV_PCM_FORMAT_DSD_U32_LE) {
+        dev_dbg(i2s_tdm->dev, "DSD format detected - bypassing audiophile processing\n");
+        return 0;
+    }
+    
+    /* IMPORTANT: Disable processing for ultra-high sampling rates (> 384 kHz) */
+    /* For 352.8/384 kHz keep processing but monitor performance */
+    if (proc->sample_rate > 384000) {
+        if (!high_rate_warning_shown) {
+            dev_info(i2s_tdm->dev, "Ultra high sample rate detected (%d Hz) - disabling processing for performance\n", 
+                     proc->sample_rate);
+            high_rate_warning_shown = true;
+        }
+        /* Skip processing for ultra-high frequencies */
+        return 0;
+    }
+    
+    if (i2s_tdm->mute) {
+        /* Fast path - fill with silence when muted */
+        memset(buffer, 0, buffer_size);
+        
+        /* Debug message only for first calls */
+        if (call_count < 5) {
+            dev_info(i2s_tdm->dev, "Audio processing: MUTED (call %d)\n", call_count++);
+        }
+        return 0;
+    }
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    frame_size = (proc->bit_depth / 8) * proc->channels;
+    frames = buffer_size / frame_size;
+    
+    proc->clipping_detected = false;
+    
+    /* Debug message only for first calls */
+    if (call_count < 5) {
+        dev_info(i2s_tdm->dev, 
+                 "Audio processing: %zu frames, %dbit, %dch, %dHz, vol=0x%x (call %d)\n",
+                 frames, proc->bit_depth, proc->channels, proc->sample_rate,
+                 proc->volume_linear_q16, call_count++);
+    } else if (call_count == 5) {
+        dev_info(i2s_tdm->dev, "Audio processing working, suppressing further debug messages\n");
+        call_count++;
+    }
+    
+    /* Debug output of first samples for 32-bit */
+    if (debug_samples && proc->format == SNDRV_PCM_FORMAT_S32_LE && frames > 0) {
+        int32_t *samples = (int32_t*)buffer;
+        dev_info(i2s_tdm->dev, "First samples BEFORE: [0]=%d [1]=%d [2]=%d [3]=%d\n",
+                 samples[0], samples[1], samples[2], samples[3]);
+    }
+    
+    /* Simple volume processing for testing - apply only if volume is not 100% */
+    if (proc->volume_linear_q16 != 65536) {
+        /* Choose processing function based on format */
+        switch (proc->format) {
+            case SNDRV_PCM_FORMAT_S16_LE:
+                if (proc->channels == 2) {
+#ifdef HAVE_NEON_SUPPORT
+                    process_stereo_16bit_neon(proc, (int16_t*)buffer, frames);
+#else
+                    process_stereo_16bit_fixed(proc, (int16_t*)buffer, frames);
+#endif
+                }
+                break;
+                
+            case SNDRV_PCM_FORMAT_S24_LE:
+                if (proc->channels == 2) {
+#ifdef HAVE_NEON_SUPPORT
+                    process_stereo_24bit_neon(proc, (int32_t*)buffer, frames);
+#else
+                    process_stereo_24bit_fixed(proc, (int32_t*)buffer, frames);
+#endif
+                }
+                break;
+                
+            case SNDRV_PCM_FORMAT_S32_LE:
+            case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+                if (proc->channels == 2) {
+#ifdef HAVE_NEON_SUPPORT
+                    process_stereo_32bit_neon(proc, (int32_t*)buffer, frames);
+#else
+                    process_stereo_32bit_fixed(proc, (int32_t*)buffer, frames);
+#endif
+                }
+                break;
+                
+            case SNDRV_PCM_FORMAT_DSD_U8:
+            case SNDRV_PCM_FORMAT_DSD_U16_LE:
+            case SNDRV_PCM_FORMAT_DSD_U32_LE:
+                /* DSD formats not processed - passed through directly */
+                dev_dbg(i2s_tdm->dev, "DSD format - no processing applied\n");
+                break;
+                
+            default:
+                /* Fallback - do not process unsupported formats */
+                spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+                dev_warn_ratelimited(i2s_tdm->dev, "Unsupported audio format: %d\n", proc->format);
+                return 0;
+        }
+    }
+    
+    /* Debug output of first samples AFTER processing */
+    if (debug_samples && proc->format == SNDRV_PCM_FORMAT_S32_LE && frames > 0) {
+        int32_t *samples = (int32_t*)buffer;
+        dev_info(i2s_tdm->dev, "First samples AFTER: [0]=%d [1]=%d [2]=%d [3]=%d\n",
+                 samples[0], samples[1], samples[2], samples[3]);
+        debug_samples = false; /* Show only once */
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    if (proc->clipping_detected) {
+        dev_warn_ratelimited(i2s_tdm->dev, 
+                           "Audiophile: Clipping detected at volume %d%%\n", 
+                           i2s_tdm->volume);
+    }
+    
+    return 0;
+}
+
+/* Update audiophile processing parameters */
+static void rockchip_audiophile_update_volume(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    
+    if (!proc) return;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    /* Use pre-calculated tables */
+    if (i2s_tdm->volume >= 0 && i2s_tdm->volume <= 100) {
+        proc->volume_db_q8 = volume_db_table[i2s_tdm->volume];
+        /* DO NOT apply volume if mute is enabled - preserve silence */
+        if (!i2s_tdm->mute) {
+            proc->volume_linear_q16 = volume_linear_table[i2s_tdm->volume];
+        }
+        /* If mute is enabled - leave volume_linear_q16 = 0 */
+    } else {
+        proc->volume_db_q8 = -24576; // -96dB
+        proc->volume_linear_q16 = 0;
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    /* Logging without float operations - use integer representation */
+    dev_info(i2s_tdm->dev, 
+             "Audiophile: Volume %d%% = %d/256 dB (linear: 0x%x, mute: %s)\n",
+             i2s_tdm->volume, 
+             proc->volume_db_q8,
+             proc->volume_linear_q16,
+             i2s_tdm->mute ? "ON" : "OFF");
+}
+
+/* Update parameters when format changes */
+static int rockchip_audiophile_set_format(struct rk_i2s_tdm_dev *i2s_tdm,
+                                         struct snd_pcm_hw_params *params)
+{
+    struct rk_audiophile_processor *proc = i2s_tdm->audio_proc;
+    unsigned long flags;
+    
+    if (!proc) return 0;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    proc->sample_rate = params_rate(params);
+    proc->channels = params_channels(params);
+    proc->format = params_format(params);
+    
+    switch (proc->format) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            proc->bit_depth = 16;
+            break;
+        case SNDRV_PCM_FORMAT_S20_3LE:
+            proc->bit_depth = 20;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            proc->bit_depth = 24;
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+        case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+            proc->bit_depth = 32;
+            break;
+        case SNDRV_PCM_FORMAT_DSD_U8:
+            proc->bit_depth = 8;
+            break;
+        case SNDRV_PCM_FORMAT_DSD_U16_LE:
+            proc->bit_depth = 16;
+            break;
+        case SNDRV_PCM_FORMAT_DSD_U32_LE:
+            proc->bit_depth = 32;
+            break;
+        default:
+            proc->bit_depth = 16;
+            break;
+    }
+    
+    /* Reset statistics */
+    proc->samples_processed = 0;
+    proc->peak_level = 0;
+    proc->clipping_detected = false;
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    dev_info(i2s_tdm->dev, 
+             "Audiophile: Format updated - %dHz, %dch, %dbit\n",
+             proc->sample_rate, proc->channels, proc->bit_depth);
+    
+    return 0;
+}
+
+/* Initialize audiophile processor */
+static int rockchip_audiophile_init(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    struct rk_audiophile_processor *proc;
+    
+    proc = devm_kzalloc(i2s_tdm->dev, sizeof(*proc), GFP_KERNEL);
+    if (!proc)
+        return -ENOMEM;
+    
+    /* Initialize parameters */
+    proc->volume_linear_q16 = 65536;  // 100% = 1.0 in Q15.16
+    proc->volume_db_q8 = 0;           // 0dB in Q23.8
+    proc->dither_enabled = true;      // Enable dithering by default
+    
+    /* Initialize PRNG for dithering */
+    get_random_bytes(proc->dither_state, sizeof(proc->dither_state));
+    
+    /* Make sure state is not 0 (for LFSR) */
+    if (proc->dither_state[0] == 0) proc->dither_state[0] = 0xACE1;
+    if (proc->dither_state[1] == 0) proc->dither_state[1] = 0xDEAD;
+    if (proc->dither_state[2] == 0) proc->dither_state[2] = 0xBEEF;
+    if (proc->dither_state[3] == 0) proc->dither_state[3] = 0xCAFE;
+    
+    i2s_tdm->audio_proc = proc;
+    spin_lock_init(&i2s_tdm->audio_proc_lock);
+    
+#ifdef HAVE_NEON_SUPPORT
+    dev_info(i2s_tdm->dev, "Audiophile processor initialized with NEON support (dither OFF)\n");
+#else
+    dev_info(i2s_tdm->dev, "Audiophile processor initialized (fixed-point mode, dither OFF)\n");
+    dev_info(i2s_tdm->dev, "NEON disabled: CONFIG_KERNEL_MODE_NEON not set in kernel config\n");
+#endif
+    
+    return 0;
+}
+
 static int to_ch_num(unsigned int val)
 {
-	int chs;
+    int chs;
 
-	switch (val) {
-	case I2S_CHN_4:
-		chs = 4;
-		break;
-	case I2S_CHN_6:
-		chs = 6;
-		break;
-	case I2S_CHN_8:
-		chs = 8;
-		break;
-	default:
-		chs = 2;
-		break;
-	}
+    switch (val) {
+    case I2S_CHN_4:
+    chs = 4;
+    break;
+    case I2S_CHN_6:
+    chs = 6;
+    break;
+    case I2S_CHN_8:
+    chs = 8;
+    break;
+    default:
+    chs = 2;
+    break;
+    }
 
-	return chs;
+    return chs;
 }
 
 static int i2s_tdm_runtime_suspend(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-
-	regcache_cache_only(i2s_tdm->regmap, true);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
+    regcache_cache_only(i2s_tdm->regmap, true);
+    
+    /* Do not turn off MCLK if continuous MCLK quirk is enabled */
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON)) {
+        clk_disable_unprepare(i2s_tdm->mclk_tx);
+        clk_disable_unprepare(i2s_tdm->mclk_rx);
+    } else {
+        dev_dbg(i2s_tdm->dev, "MCLK kept running during suspend (quirk enabled)\n");
+    }
 
-	return 0;
+    return 0;
 }
 
 static int i2s_tdm_runtime_resume(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int ret;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
 
-	ret = clk_prepare_enable(i2s_tdm->mclk_tx);
-	if (ret)
-		goto err_mclk_tx;
-
-	ret = clk_prepare_enable(i2s_tdm->mclk_rx);
-	if (ret)
-		goto err_mclk_rx;
-
-	regcache_cache_only(i2s_tdm->regmap, false);
-	regcache_mark_dirty(i2s_tdm->regmap);
-	ret = regcache_sync(i2s_tdm->regmap);
-	if (ret)
-		goto err_regmap;
+    /* Enable MCLK only if it was turned off (quirk not active) */
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON)) {
+        ret = clk_prepare_enable(i2s_tdm->mclk_tx);
+        if (ret)
+            goto err_mclk_tx;
+
+        ret = clk_prepare_enable(i2s_tdm->mclk_rx);
+        if (ret)
+            goto err_mclk_rx;
+    } else {
+        dev_dbg(i2s_tdm->dev, "MCLK already running (quirk enabled)\n");
+    }
+
+    regcache_cache_only(i2s_tdm->regmap, false);
+    regcache_mark_dirty(i2s_tdm->regmap);
+
+    ret = regcache_sync(i2s_tdm->regmap);
+    if (ret)
+        goto err_regmap;
 
-	return 0;
+    return 0;
 
 err_regmap:
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON))
+        clk_disable_unprepare(i2s_tdm->mclk_rx);
 err_mclk_rx:
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON))
+        clk_disable_unprepare(i2s_tdm->mclk_tx);
 err_mclk_tx:
-	return ret;
+    return ret;
 }
 
 static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
 {
-	return snd_soc_dai_get_drvdata(dai);
+    return snd_soc_dai_get_drvdata(dai);
 }
 
 static inline bool is_stream_active(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	unsigned int val;
+    unsigned int val;
 
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
+    regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		return (val & I2S_XFER_TXS_START);
-	else
-		return (val & I2S_XFER_RXS_START);
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return (val & I2S_XFER_TXS_START);
+    else
+    return (val & I2S_XFER_RXS_START);
 }
 
 #ifdef HAVE_SYNC_RESET
 #if defined(CONFIG_ARM) && !defined(writeq)
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
-	asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
+    asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
 }
 #define writeq(v,c) ({ __iowmb(); __raw_writeq((__force u64) cpu_to_le64(v), c); })
 #endif
 
 static void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
-	void __iomem *cru_reset, *addr;
-	unsigned long flags;
-	u64 val;
-
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
-
-	tx_id = i2s_tdm->tx_reset_id;
-	rx_id = i2s_tdm->rx_reset_id;
-	if (tx_id < 0 || rx_id < 0)
-		return;
-
-	tx_bank = tx_id / 16;
-	tx_offset = tx_id % 16;
-	rx_bank = rx_id / 16;
-	rx_offset = rx_id % 16;
-
-	dev_dbg(i2s_tdm->dev,
-		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
-		tx_bank, rx_bank, tx_offset, rx_offset);
-
-	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
-
-	switch (abs(tx_bank - rx_bank)) {
-	case 0:
-		writel(BIT(tx_offset) | BIT(rx_offset) |
-		       (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		break;
-	case 1:
-		if (tx_bank < rx_bank) {
-			val = BIT(rx_offset) | (BIT(rx_offset) << 16);
-			val <<= 32;
-			val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
-			addr = cru_reset + (tx_bank * 4);
-		} else {
-			val = BIT(tx_offset) | (BIT(tx_offset) << 16);
-			val <<= 32;
-			val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
-			addr = cru_reset + (rx_bank * 4);
-		}
-
-		if (IS_ALIGNED((uintptr_t)addr, 8)) {
-			writeq(val, addr);
-			break;
-		}
-		fallthrough;
-	default:
-		local_irq_save(flags);
-		writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
-		       cru_reset + (rx_bank * 4));
-		local_irq_restore(flags);
-		break;
-	}
-	/* delay for reset assert done */
-	udelay(10);
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel(BIT(tx_offset) | BIT(rx_offset) |
+           (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
+
+    /* delay for reset assert done */
+    udelay(10);
 }
 
 static void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
-	void __iomem *cru_reset, *addr;
-	unsigned long flags;
-	u64 val;
-
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
-
-	tx_id = i2s_tdm->tx_reset_id;
-	rx_id = i2s_tdm->rx_reset_id;
-	if (tx_id < 0 || rx_id < 0)
-		return;
-
-	tx_bank = tx_id / 16;
-	tx_offset = tx_id % 16;
-	rx_bank = rx_id / 16;
-	rx_offset = rx_id % 16;
-
-	dev_dbg(i2s_tdm->dev,
-		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
-		tx_bank, rx_bank, tx_offset, rx_offset);
-
-	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
-
-	switch (abs(tx_bank - rx_bank)) {
-	case 0:
-		writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		break;
-	case 1:
-		if (tx_bank < rx_bank) {
-			val = (BIT(rx_offset) << 16);
-			val <<= 32;
-			val |= (BIT(tx_offset) << 16);
-			addr = cru_reset + (tx_bank * 4);
-		} else {
-			val = (BIT(tx_offset) << 16);
-			val <<= 32;
-			val |= (BIT(rx_offset) << 16);
-			addr = cru_reset + (rx_bank * 4);
-		}
-
-		if (IS_ALIGNED((uintptr_t)addr, 8)) {
-			writeq(val, addr);
-			break;
-		}
-		fallthrough;
-	default:
-		local_irq_save(flags);
-		writel((BIT(tx_offset) << 16),
-		       cru_reset + (tx_bank * 4));
-		writel((BIT(rx_offset) << 16),
-		       cru_reset + (rx_bank * 4));
-		local_irq_restore(flags);
-		break;
-	}
-	/* delay for reset deassert done */
-	udelay(10);
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel((BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel((BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
+
+    /* delay for reset deassert done */
+    udelay(10);
 }
 
 /*
@@ -369,16 +1251,18 @@
  */
 static void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	rockchip_i2s_tdm_reset_assert(i2s_tdm);
-	rockchip_i2s_tdm_reset_deassert(i2s_tdm);
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
 }
 #else
 static inline void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
 static inline void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
 static inline void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
@@ -386,57 +1270,59 @@
 
 static void rockchip_i2s_tdm_reset(struct reset_control *rc)
 {
-	if (IS_ERR_OR_NULL(rc))
-		return;
+    if (IS_ERR_OR_NULL(rc))
+    return;
 
-	reset_control_assert(rc);
-	/* delay for reset assert done */
-	udelay(10);
-	reset_control_deassert(rc);
-	/* delay for reset deassert done */
-	udelay(10);
+    reset_control_assert(rc);
+    /* delay for reset assert done */
+    udelay(10);
+
+    reset_control_deassert(rc);
+    /* delay for reset deassert done */
+    udelay(10);
 }
 
 static int rockchip_i2s_tdm_clear(struct rk_i2s_tdm_dev *i2s_tdm,
-				  unsigned int clr)
+      unsigned int clr)
 {
-	struct reset_control *rst = NULL;
-	unsigned int val = 0;
-	int ret = 0;
-
-	if (!i2s_tdm->is_master_mode)
-		goto reset;
-
-	switch (clr) {
-	case I2S_CLR_TXC:
-		rst = i2s_tdm->tx_reset;
-		break;
-	case I2S_CLR_RXC:
-		rst = i2s_tdm->rx_reset;
-		break;
-	case I2S_CLR_TXC | I2S_CLR_RXC:
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
-	ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
-					      !(val & clr), 10, 100);
-	if (ret < 0) {
-		dev_warn(i2s_tdm->dev, "failed to clear %u\n", clr);
-		goto reset;
-	}
+    struct reset_control *rst = NULL;
+    unsigned int val = 0;
+    int ret = 0;
+
+    if (!i2s_tdm->is_master_mode)
+    goto reset;
+
+    switch (clr) {
+    case I2S_CLR_TXC:
+    rst = i2s_tdm->tx_reset;
+    break;
+    case I2S_CLR_RXC:
+    rst = i2s_tdm->rx_reset;
+    break;
+    case I2S_CLR_TXC | I2S_CLR_RXC:
+    break;
+    default:
+    return -EINVAL;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
+
+    ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
+              !(val & clr), 10, 100);
+    if (ret < 0) {
+    dev_warn(i2s_tdm->dev, "failed to clear %u\n", clr);
+    goto reset;
+    }
 
-	return 0;
+    return 0;
 
 reset:
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_sync_reset(i2s_tdm);
-	else
-		rockchip_i2s_tdm_reset(rst);
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_sync_reset(i2s_tdm);
+    else
+    rockchip_i2s_tdm_reset(rst);
 
-	return 0;
+    return 0;
 }
 
 /*
@@ -446,2088 +1332,3324 @@
  */
 static void rockchip_i2s_tdm_tx_fifo_padding(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
 {
-	unsigned int val, w, c, i;
+    unsigned int val, w, c, i;
 
-	if (!en)
-		return;
+    if (!en)
+    return;
 
-	regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-	w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
-	c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
+    c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
 
-	for (i = 0; i < c; i++)
-		regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
+    for (i = 0; i < c; i++)
+    regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
 }
 
 static void rockchip_i2s_tdm_fifo_xrun_detect(struct rk_i2s_tdm_dev *i2s_tdm,
-					      int stream, bool en)
+              int stream, bool en)
 {
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* clear irq status which was asserted before TXUIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIE_MASK,
-				   I2S_INTCR_TXUIE(en));
-	} else {
-		/* clear irq status which was asserted before RXOIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIE_MASK,
-				   I2S_INTCR_RXOIE(en));
-	}
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    /* clear irq status which was asserted before TXUIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIE_MASK,
+       I2S_INTCR_TXUIE(en));
+    } else {
+    /* clear irq status which was asserted before RXOIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIE_MASK,
+       I2S_INTCR_RXOIE(en));
+    }
 }
 
 static void rockchip_i2s_tdm_dma_ctrl(struct rk_i2s_tdm_dev *i2s_tdm,
-				      int stream, bool en)
+          int stream, bool en)
 {
-	if (!en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
+    if (!en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
-			rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_TDE_MASK,
-				   I2S_DMACR_TDE(en));
-		/*
-		 * Explicitly delay 1 usec for dma to fill FIFO,
-		 * though there was a implied HW delay that around
-		 * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
-		 * to FIFO-pop.
-		 *
-		 * 1 usec is enough to fill at lease 4 entry each FIFO
-		 * @192k 8ch 32bit situation.
-		 */
-		udelay(1);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_RDE_MASK,
-				   I2S_DMACR_RDE(en));
-	}
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
+        rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_TDE_MASK,
+       I2S_DMACR_TDE(en));
+    /*
+     * Explicitly delay 1 usec for dma to fill FIFO,
+     * though there was a implied HW delay that around
+     * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
+     * to FIFO-pop.
+     *
+     * 1 usec is enough to fill at lease 4 entry each FIFO
+     * @192k 8ch 32bit situation.
+     */
+    udelay(1);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_RDE_MASK,
+       I2S_DMACR_RDE(en));
+    }
 
-	if (en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
+    if (en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
 }
 
 static void rockchip_i2s_tdm_xfer_start(struct rk_i2s_tdm_dev *i2s_tdm,
-					int stream)
+        int stream)
 {
-	if (i2s_tdm->clk_trcm) {
-		rockchip_i2s_tdm_reset_assert(i2s_tdm);
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_MASK |
-				   I2S_XFER_RXS_MASK,
-				   I2S_XFER_TXS_START |
-				   I2S_XFER_RXS_START);
-		rockchip_i2s_tdm_reset_deassert(i2s_tdm);
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_MASK,
-				   I2S_XFER_TXS_START);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_RXS_MASK,
-				   I2S_XFER_RXS_START);
-	}
+    if (i2s_tdm->clk_trcm) {
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK |
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_TXS_START |
+       I2S_XFER_RXS_START);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK,
+       I2S_XFER_TXS_START);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_RXS_START);
+    }
 }
 
 static void rockchip_i2s_tdm_xfer_stop(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int stream, bool force)
+           int stream, bool force)
 {
-	unsigned int msk, val, clr;
+    unsigned int msk, val, clr;
 
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
-		return;
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
+    return;
 
-	if (i2s_tdm->clk_trcm) {
-		msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
-		val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_TXC | I2S_CLR_RXC;
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_STOP;
-		clr = I2S_CLR_TXC;
-	} else {
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_RXC;
-	}
+    if (i2s_tdm->clk_trcm) {
+    msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
+    val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_TXC | I2S_CLR_RXC;
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    msk = I2S_XFER_TXS_MASK;
+    val = I2S_XFER_TXS_STOP;
+    clr = I2S_CLR_TXC;
+    } else {
+    msk = I2S_XFER_RXS_MASK;
+    val = I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_RXC;
+    }
 
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
 
-	/* delay for LRCK signal integrity */
-	udelay(150);
+    /* delay for LRCK signal integrity */
+    udelay(150);
 
-	rockchip_i2s_tdm_clear(i2s_tdm, clr);
+    rockchip_i2s_tdm_clear(i2s_tdm, clr);
 }
 
 static void rockchip_i2s_tdm_xfer_trcm_start(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	unsigned long flags;
+    unsigned long flags;
 
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_inc_return(&i2s_tdm->refcount) == 1)
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_inc_return(&i2s_tdm->refcount) == 1)
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_i2s_tdm_xfer_trcm_stop(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	unsigned long flags;
+    unsigned long flags;
 
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_dec_and_test(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_dec_and_test(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_i2s_tdm_trcm_pause(struct snd_pcm_substream *substream,
-					struct rk_i2s_tdm_dev *i2s_tdm)
+        struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int stream = substream->stream;
-	int bstream = SNDRV_PCM_STREAM_LAST - stream;
+    int stream = substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - stream;
 
-	/* disable dma for both tx and rx */
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
-	rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
+    /* disable dma for both tx and rx */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
 }
 
 static void rockchip_i2s_tdm_trcm_resume(struct snd_pcm_substream *substream,
-					 struct rk_i2s_tdm_dev *i2s_tdm)
+         struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
+
+    /*
+     * just resume bstream, because current stream will be
+     * startup in the trigger-cmd-START
+     */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+}
 
-	/*
-	 * just resume bstream, because current stream will be
-	 * startup in the trigger-cmd-START
-	 */
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
-	rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+/* Additional function to check pause state */
+static bool rockchip_i2s_tdm_is_paused(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return i2s_tdm->playback_paused;
+    else
+    return i2s_tdm->capture_paused;
 }
 
 static void rockchip_i2s_tdm_start(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	/*
-	 * On HDMI-PATH-ALWAYS-ON situation, we almost keep XFER always on,
-	 * so, for new data start, suggested to STOP-CLEAR-START to make sure
-	 * data aligned.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-	}
-
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
-
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
-	else
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    /* Check if stream is in pause state */
+    if (rockchip_i2s_tdm_is_paused(i2s_tdm, stream)) {
+    dev_dbg(i2s_tdm->dev, "Stream is paused, not starting\n");
+    return;
+    }
+
+    /* FIX: Enable mute BEFORE start to prevent clicks */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        rockchip_i2s_tdm_trigger_auto_mute(i2s_tdm);
+        /* DO NOT use msleep in start/stop - can cause deadlock in atomic context */
+    }
+
+    /* Always start DMA and transmission */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
+    
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    
+    /* Check mute considering audiophile processing */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK && 
+        (i2s_tdm->mute || (i2s_tdm->audio_proc && i2s_tdm->audio_proc->volume_linear_q16 == 0))) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback started with mute or zero volume\n");
+    /* DO NOT disable DMA when muted - let GPIO mute do its job */
+    /* rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0); */
+    }
 }
 
 static void rockchip_i2s_tdm_stop(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    /* FIX: Enable mute BEFORE stop to prevent clicks */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        rockchip_i2s_tdm_trigger_stop_mute(i2s_tdm);
+        /* Delay already performed inside trigger_stop_mute */
+    }
+    
+    /* First stop transmission (BCLK/DATA), then DMA */
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm);
+    else
+        rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
+    
+    /* Then stop DMA */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    /* Only logging, no mute state change */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback stopped, mute state: %s\n", 
+        i2s_tdm->mute ? "enabled" : "disabled");
+    }
+}
+
+/* New functions for pause/resume handling */
+static void rockchip_i2s_tdm_pause(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = true;
+    } else {
+    if (i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = true;
+    }
+
+    /* Disable DMA but preserve device state */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    /* Use special function for TRCM mode */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+    } else {
+    /* For normal mode, pause transmission */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_STOP);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_STOP);
+    }
+    }
+
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream paused\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
+}
+
+static void rockchip_i2s_tdm_resume(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (!i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = false;
+    } else {
+    if (!i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = false;
+    }
+
+    /* Use special function for TRCM mode */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    } else {
+    /* Restore data transmission */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_START);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_START);
+    }
+    }
+
+    /* Enable DMA */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
 
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm);
-	else
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream resumed\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
 }
 
 static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
-				    unsigned int fmt)
+        unsigned int fmt)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
-	unsigned int mask = 0, val = 0, tdm_val = 0;
-	int ret = 0;
-	bool is_tdm = i2s_tdm->tdm_mode;
-
-	pm_runtime_get_sync(cpu_dai->dev);
-	mask = I2S_CKR_MSS_MASK;
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBS_CFS:
-		val = I2S_CKR_MSS_MASTER;
-		i2s_tdm->is_master_mode = true;
-		break;
-	case SND_SOC_DAIFMT_CBM_CFM:
-		val = I2S_CKR_MSS_SLAVE;
-		i2s_tdm->is_master_mode = false;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = I2S_TXCR_IBM_RSJM;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = I2S_TXCR_IBM_LSJM;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		val = I2S_TXCR_IBM_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
-		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
-		break;
-	case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
-		val = I2S_TXCR_TFS_PCM;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-
-	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		val = I2S_RXCR_IBM_RSJM;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		val = I2S_RXCR_IBM_LSJM;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		val = I2S_RXCR_IBM_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
-		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
-		break;
-	case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
-		val = I2S_RXCR_TFS_PCM;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-
-	if (is_tdm) {
-		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-		case SND_SOC_DAIFMT_RIGHT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_LEFT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(1);
-			break;
-		case SND_SOC_DAIFMT_I2S:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(0);
-			break;
-		case SND_SOC_DAIFMT_DSP_A:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_DSP_B:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(4);
-			break;
-		default:
-			ret = -EINVAL;
-			goto err_pm_put;
-		}
-
-		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
-		if (i2s_tdm->tdm_fsync_half_frame)
-			tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
-		else
-			tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
-
-		mask = I2S_TXCR_TFS_MASK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-
-		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
-		       TDM_SHIFT_CTRL_MSK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-				   mask, tdm_val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-				   mask, tdm_val);
-
-		if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-			/* refine frame width for TDM_I2S_ONE_FRAME */
-			mask = TDM_FRAME_WIDTH_MSK;
-			tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-					   mask, tdm_val);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-					   mask, tdm_val);
-		}
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    unsigned int mask = 0, val = 0, tdm_val = 0;
+    int ret = 0;
+    bool is_tdm = i2s_tdm->tdm_mode;
+
+    pm_runtime_get_sync(cpu_dai->dev);
+    
+    /* Save format for forced changes application */
+    i2s_tdm->format = fmt;
+
+    mask = I2S_CKR_MSS_MASK;
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+    val = I2S_CKR_MSS_MASTER;
+    i2s_tdm->is_master_mode = true;
+    break;
+    case SND_SOC_DAIFMT_CBM_CFM:
+    val = I2S_CKR_MSS_SLAVE;
+    i2s_tdm->is_master_mode = false;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+    mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_NB_IF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    case SND_SOC_DAIFMT_IB_NF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_IB_IF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    /* Apply PCM channel swap if enabled and not in DSD mode */
+    if (i2s_tdm->pcm_channel_swap && !i2s_tdm->dsd_mode_active) {
+        /* Invert LRCK polarity for channel switching */
+        bool was_inverted = (val & I2S_CKR_TLP_INVERTED) != 0;
+        val &= ~(I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK);
+        if (was_inverted) {
+            val |= I2S_CKR_TLP_NORMAL | I2S_CKR_RLP_NORMAL;
+        } else {
+            val |= I2S_CKR_TLP_INVERTED | I2S_CKR_RLP_INVERTED;
+        }
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+
+    mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_TXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_TXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_TXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_TXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+    mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_RXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_RXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_RXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_RXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    if (is_tdm) {
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_LEFT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(1);
+        break;
+    case SND_SOC_DAIFMT_I2S:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(0);
+        break;
+    case SND_SOC_DAIFMT_DSP_A:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_DSP_B:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(4);
+        break;
+    default:
+        ret = -EINVAL;
+        goto err_pm_put;
+    }
+
+    tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+    if (i2s_tdm->tdm_fsync_half_frame)
+        tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
+    else
+        tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+    mask = I2S_TXCR_TFS_MASK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+           TDM_SHIFT_CTRL_MSK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+       mask, tdm_val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+       mask, tdm_val);
+
+    if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+        /* refine frame width for TDM_I2S_ONE_FRAME */
+        mask = TDM_FRAME_WIDTH_MSK;
+        tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, tdm_val);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, tdm_val);
+    }
+    }
 
 err_pm_put:
-	pm_runtime_put(cpu_dai->dev);
+    pm_runtime_put(cpu_dai->dev);
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct clk *clk, unsigned long rate,
-					 int ppm)
+         struct clk *clk, unsigned long rate,
+         int ppm)
 {
-	unsigned long rate_target;
-	int delta, ret;
+    unsigned long rate_target;
+    int delta, ret;
 
-	if (ppm == i2s_tdm->clk_ppm)
-		return 0;
+    if (ppm == i2s_tdm->clk_ppm)
+    return 0;
 
-	ret = rockchip_pll_clk_compensation(clk, ppm);
-	if (ret != -ENOSYS)
-		goto out;
+    ret = rockchip_pll_clk_compensation(clk, ppm);
+    if (ret != -ENOSYS)
+    goto out;
 
-	delta = (ppm < 0) ? -1 : 1;
-	delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
+    delta = (ppm < 0) ? -1 : 1;
+    delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
 
-	rate_target = rate + delta;
+    rate_target = rate + delta;
+    if (!rate_target)
+    return -EINVAL;
 
-	if (!rate_target)
-		return -EINVAL;
+    ret = clk_set_rate(clk, rate_target);
+    if (ret)
+    return ret;
 
-	ret = clk_set_rate(clk, rate_target);
-	if (ret)
-		return ret;
 out:
-	if (!ret)
-		i2s_tdm->clk_ppm = ppm;
+    if (!ret)
+    i2s_tdm->clk_ppm = ppm;
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-					   struct snd_pcm_substream *substream,
-					   unsigned int lrck_freq)
+           struct snd_pcm_substream *substream,
+           unsigned int lrck_freq)
 {
-	struct clk *mclk_root;
-	struct clk *mclk_parent;
-	unsigned int mclk_root_freq;
-	unsigned int mclk_root_initial_freq;
-	unsigned int mclk_parent_freq;
-	unsigned int div, delta;
-	uint64_t ppm;
-	int ret;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		mclk_parent = i2s_tdm->mclk_tx_src;
-	else
-		mclk_parent = i2s_tdm->mclk_rx_src;
-
-	switch (lrck_freq) {
-	case 8000:
-	case 16000:
-	case 24000:
-	case 32000:
-	case 48000:
-	case 64000:
-	case 96000:
-	case 192000:
-		mclk_root = i2s_tdm->mclk_root0;
-		mclk_root_freq = i2s_tdm->mclk_root0_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
-		break;
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-	case 176400:
-		mclk_root = i2s_tdm->mclk_root1;
-		mclk_root_freq = i2s_tdm->mclk_root1_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
-		break;
-	default:
-		dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
-			lrck_freq);
-		return -EINVAL;
-	}
-
-	ret = clk_set_parent(mclk_parent, mclk_root);
-	if (ret)
-		goto out;
-
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
-					    mclk_root_freq, 0);
-	if (ret)
-		goto out;
-
-	delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
-	ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
-
-	if (ppm) {
-		div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
-		if (!div)
-			return -EINVAL;
-
-		mclk_root_freq = mclk_parent_freq * round_up(div, 2);
-
-		ret = clk_set_rate(mclk_root, mclk_root_freq);
-		if (ret)
-			goto out;
-
-		i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
-	}
-
-	ret = clk_set_rate(mclk_parent, mclk_parent_freq);
-	if (ret)
-		goto out;
+    struct clk *mclk_root;
+    struct clk *mclk_parent;
+    unsigned int mclk_root_freq;
+    unsigned int mclk_root_initial_freq;
+    unsigned int mclk_parent_freq;
+    unsigned int div, delta;
+    uint64_t ppm;
+    int ret;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    mclk_parent = i2s_tdm->mclk_tx_src;
+    else
+    mclk_parent = i2s_tdm->mclk_rx_src;
+
+    switch (lrck_freq) {
+    case 8000:
+    case 16000:
+    case 24000:
+    case 32000:
+    case 48000:
+    case 64000:
+    case 96000:
+    case 192000:
+    case 384000:
+    mclk_root = i2s_tdm->mclk_root0;
+    mclk_root_freq = i2s_tdm->mclk_root0_freq;
+    mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
+    mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+    break;
+    case 11025:
+    case 22050:
+    case 44100:
+    case 88200:
+    case 176400:
+    case 352800:
+    mclk_root = i2s_tdm->mclk_root1;
+    mclk_root_freq = i2s_tdm->mclk_root1_freq;
+    mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
+    mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+    break;
+    default:
+    dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
+        lrck_freq);
+    return -EINVAL;
+    }
+
+    ret = clk_set_parent(mclk_parent, mclk_root);
+    if (ret)
+    goto out;
+
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
+            mclk_root_freq, 0);
+    if (ret)
+    goto out;
+
+    delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
+    ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
+
+    if (ppm) {
+    div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
+    if (!div)
+        return -EINVAL;
+
+    mclk_root_freq = mclk_parent_freq * round_up(div, 2);
+
+    ret = clk_set_rate(mclk_root, mclk_root_freq);
+    if (ret)
+        goto out;
+
+    i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
+    i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
+    }
+
+    ret = clk_set_rate(mclk_parent, mclk_parent_freq);
+    if (ret)
+    goto out;
 
 out:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-				     struct snd_pcm_substream *substream,
-				     struct clk **mclk)
+         struct snd_pcm_substream *substream,
+         struct clk **mclk)
 {
-	unsigned int mclk_freq;
-	int ret;
+    unsigned int mclk_freq;
+    int ret;
 
-	if (i2s_tdm->clk_trcm) {
-		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
-			dev_err(i2s_tdm->dev,
-				"clk_trcm, tx: %d and rx: %d should be same\n",
-				i2s_tdm->mclk_tx_freq,
-				i2s_tdm->mclk_rx_freq);
-			ret = -EINVAL;
-			goto err;
-		}
-
-		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
-		if (ret)
-			goto err;
-
-		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
-		if (ret)
-			goto err;
-
-		/* mclk_rx is also ok. */
-		*mclk = i2s_tdm->mclk_tx;
-	} else {
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			*mclk = i2s_tdm->mclk_tx;
-			mclk_freq = i2s_tdm->mclk_tx_freq;
-		} else {
-			*mclk = i2s_tdm->mclk_rx;
-			mclk_freq = i2s_tdm->mclk_rx_freq;
-		}
-
-		ret = clk_set_rate(*mclk, mclk_freq);
-		if (ret)
-			goto err;
-	}
+    if (i2s_tdm->clk_trcm) {
+    if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+        dev_err(i2s_tdm->dev,
+    "clk_trcm, tx: %d and rx: %d should be same\n",
+    i2s_tdm->mclk_tx_freq,
+    i2s_tdm->mclk_rx_freq);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+    if (ret)
+        goto err;
+
+    ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+    if (ret)
+        goto err;
+
+    /* mclk_rx is also ok. */
+    *mclk = i2s_tdm->mclk_tx;
+    } else {
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        *mclk = i2s_tdm->mclk_tx;
+        mclk_freq = i2s_tdm->mclk_tx_freq;
+    } else {
+        *mclk = i2s_tdm->mclk_rx;
+        mclk_freq = i2s_tdm->mclk_rx_freq;
+    }
+
+    ret = clk_set_rate(*mclk, mclk_freq);
+    if (ret)
+        goto err;
+    }
 
-	return 0;
+    return 0;
 
 err:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
-				     struct snd_soc_dai *dai)
+         struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int usable_chs = MULTIPLEX_CH_MAX;
-	unsigned int val = 0;
-
-	if (!i2s_tdm->io_multiplex)
-		return 0;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		struct snd_pcm_str *playback_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
-
-		if (playback_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-			val &= I2S_TXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		val &= I2S_RXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Capture chs(%d) > usable chs(%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-
-		switch (val) {
-		case I2S_CHN_4:
-			val = I2S_IO_6CH_OUT_4CH_IN;
-			break;
-		case I2S_CHN_6:
-			val = I2S_IO_4CH_OUT_6CH_IN;
-			break;
-		case I2S_CHN_8:
-			val = I2S_IO_2CH_OUT_8CH_IN;
-			break;
-		default:
-			val = I2S_IO_8CH_OUT_2CH_IN;
-			break;
-		}
-	} else {
-		struct snd_pcm_str *capture_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
-
-		if (capture_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-			val &= I2S_RXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		val &= I2S_TXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Playback chs(%d) > usable chs(%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-
-		switch (val) {
-		case I2S_CHN_4:
-			val = I2S_IO_4CH_OUT_6CH_IN;
-			break;
-		case I2S_CHN_6:
-			val = I2S_IO_6CH_OUT_4CH_IN;
-			break;
-		case I2S_CHN_8:
-			val = I2S_IO_8CH_OUT_2CH_IN;
-			break;
-		default:
-			val = I2S_IO_2CH_OUT_8CH_IN;
-			break;
-		}
-	}
-
-	val <<= i2s_tdm->soc_data->grf_shift;
-	val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
-	regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int usable_chs = MULTIPLEX_CH_MAX;
+    unsigned int val = 0;
+
+    if (!i2s_tdm->io_multiplex)
+    return 0;
+
+    if (IS_ERR(i2s_tdm->grf))
+    return 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+    struct snd_pcm_str *playback_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+
+    if (playback_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+        val &= I2S_TXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    val &= I2S_RXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Capture chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    default:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    }
+    } else {
+    struct snd_pcm_str *capture_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+    if (capture_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+        val &= I2S_RXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    val &= I2S_TXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Playback chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    default:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    }
+    }
+
+    val <<= i2s_tdm->soc_data->grf_shift;
+    val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
+    regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
 
-	return 0;
+    return 0;
 }
 
 static bool is_params_dirty(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai,
-			    unsigned int div_bclk,
-			    unsigned int div_lrck,
-			    unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
-
-	regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
-	last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
-	if (last_div_bclk != div_bclk)
-		return true;
-
-	regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
-	last_div_lrck = ((val & I2S_CKR_TSD_MASK) >> I2S_CKR_TSD_SHIFT) + 1;
-	if (last_div_lrck != div_lrck)
-		return true;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
-	} else {
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
-	}
-	if (last_fmt != fmt)
-		return true;
+            struct snd_soc_dai *dai,
+            unsigned int div_bclk,
+            unsigned int div_lrck,
+            unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
+
+    regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
+    last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
+    if (last_div_bclk != div_bclk)
+    return true;
+
+    regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
+    last_div_lrck = ((val & I2S_CKR_TSD_MASK) >> I2S_CKR_TSD_SHIFT) + 1;
+    if (last_div_lrck != div_lrck)
+    return true;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
+    } else {
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
+    }
 
-	return false;
+    if (last_fmt != fmt)
+    return true;
+
+    return false;
 }
 
 static int rockchip_i2s_tdm_params_trcm(struct snd_pcm_substream *substream,
-					struct snd_soc_dai *dai,
-					unsigned int div_bclk,
-					unsigned int div_lrck,
-					unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned long flags;
-
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (atomic_read(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-			   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
-			   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
-			   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	else
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-
-	if (atomic_read(&i2s_tdm->refcount))
-		rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+        struct snd_soc_dai *dai,
+        unsigned int div_bclk,
+        unsigned int div_lrck,
+        unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned long flags;
+
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+           I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+           I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+           I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    else
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params(struct snd_pcm_substream *substream,
-				   struct snd_soc_dai *dai,
-				   unsigned int div_bclk,
-				   unsigned int div_lrck,
-				   unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int stream = substream->stream;
-
-	if (is_stream_active(i2s_tdm, stream))
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_TXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_TSD_MASK,
-				   I2S_CKR_TSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_RSD_MASK,
-				   I2S_CKR_RSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-	}
-
-	/*
-	 * Bring back CLK ASAP after cfg changed to make SINK devices active
-	 * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
-	 * sound issue. at the moment, it's 8K@60Hz display situation.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	}
+       struct snd_soc_dai *dai,
+       unsigned int div_bclk,
+       unsigned int div_lrck,
+       unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int stream = substream->stream;
+
+    if (is_stream_active(i2s_tdm, stream))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_TSD_MASK,
+       I2S_CKR_TSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK,
+       I2S_CKR_RSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+    }
+
+    /*
+     * Bring back CLK ASAP after cfg changed to make SINK devices active
+     * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
+     * sound issue. at the moment, it's 8K@60Hz display situation.
+     */
+    if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
+        (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
+        (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    }
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params_channels(struct snd_pcm_substream *substream,
-					    struct snd_pcm_hw_params *params,
-					    struct snd_soc_dai *dai)
+            struct snd_pcm_hw_params *params,
+            struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int reg_fmt, fmt;
-	int ret = 0;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		reg_fmt = I2S_TXCR;
-	else
-		reg_fmt = I2S_RXCR;
-
-	regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
-	fmt &= I2S_TXCR_TFS_MASK;
-
-	if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-		switch (params_channels(params)) {
-		case 16:
-			ret = I2S_CHN_8;
-			break;
-		case 12:
-			ret = I2S_CHN_6;
-			break;
-		case 8:
-			ret = I2S_CHN_4;
-			break;
-		case 4:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	} else {
-		switch (params_channels(params)) {
-		case 8:
-			ret = I2S_CHN_8;
-			break;
-		case 6:
-			ret = I2S_CHN_6;
-			break;
-		case 4:
-			ret = I2S_CHN_4;
-			break;
-		case 2:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int reg_fmt, fmt;
+    int ret = 0;
+    snd_pcm_format_t format = params_format(params);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    reg_fmt = I2S_TXCR;
+    else
+    reg_fmt = I2S_RXCR;
+    /* Special handling for DSD formats - force 4-channel configuration for stereo DSD */
+    if (is_dsd(format)) {
+        dev_info(i2s_tdm->dev, "DSD channel config: FORCING 4-channel setup for stereo DSD\n");
+        /* Force 4-channel mode for DSD stereo */
+        regmap_update_bits(i2s_tdm->regmap, reg_fmt, I2S_TXCR_CSR_MASK, I2S_CHN_4);
+        return I2S_CHN_4; /* DSD requires 4 channels for stereo */
+    }
+    regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
+    fmt &= I2S_TXCR_TFS_MASK;
+
+    if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+    switch (params_channels(params)) {
+    case 16:
+        ret = I2S_CHN_8;
+        break;
+    case 12:
+        ret = I2S_CHN_6;
+        break;
+    case 8:
+        ret = I2S_CHN_4;
+        break;
+    case 4:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    } else {
+    switch (params_channels(params)) {
+    case 8:
+        ret = I2S_CHN_8;
+        break;
+    case 6:
+        ret = I2S_CHN_6;
+        break;
+    case 4:
+        ret = I2S_CHN_4;
+        break;
+    case 2:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    }
 
-	return ret;
+    return ret;
 }
 
+/* Updated hw_params function with audiophile processing */
 static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
-				      struct snd_pcm_hw_params *params,
-				      struct snd_soc_dai *dai)
+          struct snd_pcm_hw_params *params,
+          struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	struct snd_dmaengine_dai_dma_data *dma_data;
-	struct clk *mclk;
-	int ret = 0;
-	unsigned int val = 0;
-	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
-	bool s2mono = i2s_tdm->s2mono;
-
-	dma_data = snd_soc_dai_get_dma_data(dai, substream);
-	dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
-
-			// original
-		if(0) {
-			if (i2s_tdm->mclk_calibrate)
-				rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
-								params_rate(params));
-
-			ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
-			if (ret)
-				goto err;
-		}
-			//  
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    struct snd_dmaengine_dai_dma_data *dma_data;
+    struct clk *mclk;
+    int ret = 0;
+    unsigned int val = 0;
+    unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
+
+    dma_data = snd_soc_dai_get_dma_data(dai, substream);
+    dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
+
+    /* Start automatic mute when parameters change */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        rockchip_i2s_tdm_trigger_auto_mute(i2s_tdm);
+    }
+    
+    /* Update audiophile processor parameters */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        rockchip_audiophile_set_format(i2s_tdm, params);
+    }
+
+    if (i2s_tdm->is_master_mode) {
+        if (i2s_tdm->mclk_calibrate)
+            rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+                            params_rate(params));
 //+++
-	if (i2s_tdm->is_master_mode) {
-		mclk = i2s_tdm->mclk_tx;		// !must check if RX
-
-		if( params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ) s2mono = 1;
-		if( i2s_tdm->tdm_mode != true ) {
-			if( params_format(params) == SNDRV_PCM_FORMAT_S16_LE ) {
-				div_lrck = 32; i2s_tdm->frame_width = 32;
-				//s2mono = 0;
-			} else if( s2mono ) {
-				div_lrck = 32; i2s_tdm->frame_width = 32;
-			} else {
-				div_lrck = 64; i2s_tdm->frame_width = 64;
-			} 
-		}
-
-		if( !i2s_tdm->mclk_external ){
-			//err = clk_set_rate(mclk, DEFAULT_MCLK_FS * params_rate(params));
-			if( params_rate(params) % 44100 )
-				ret = clk_set_rate(mclk, 512 * 48000);
-			else
-				ret = clk_set_rate(mclk, 512 * 44100);
-			if (ret)
-				goto err;
-		}
-
-
-		if( i2s_tdm->mclk_external ){
-			if( i2s_tdm->mclk_ext_mux ) {
-				if( params_rate(params) % 44100 ) {
-					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
-				}
-				else {
-					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
-				}
-			}
-		}
+        if( i2s_tdm->mclk_external ){
+            mclk = i2s_tdm->mclk_tx;
+            if( i2s_tdm->mclk_ext_mux ) {
+                /* Consider MCLK multiplier for external PLL */
+                if( params_rate(params) % 44100 ) {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
+                    /* 48kHz family: 24.576MHz (512x) or 49.152MHz (1024x) */
+                    if (i2s_tdm->mclk_multiplier == 1024) {
+                        clk_set_rate(i2s_tdm->mclk_tx, 49152000);
+                    } else {
+                        clk_set_rate(i2s_tdm->mclk_tx, 24576000);
+                    }
+                }
+                else {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
+                    /* 44.1kHz family: 22.579MHz (512x) or 45.158MHz (1024x) */
+                    if (i2s_tdm->mclk_multiplier == 1024) {
+                        clk_set_rate(i2s_tdm->mclk_tx, 45158400);
+                    } else {
+                        clk_set_rate(i2s_tdm->mclk_tx, 22579200);
+                    }
+                }
+                dev_info(i2s_tdm->dev, "External PLL: MCLK set to %lu Hz (multiplier %dx)\n", 
+                         clk_get_rate(i2s_tdm->mclk_tx), i2s_tdm->mclk_multiplier);
+            }
+        }
+        else {
+            ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+            if (ret)
+                goto err;
+        }
 //+++
 
-		mclk_rate = clk_get_rate(mclk);
-		//--bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
-		bclk_rate = i2s_tdm->frame_width * params_rate(params);
-		if (!bclk_rate) {
-			ret = -EINVAL;
-			goto err;
-		}
-		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
-		div_lrck = bclk_rate / params_rate(params);
-	}
+        mclk_rate = clk_get_rate(mclk);
+        
+        /* Special handling for DSD formats */
+        if (is_dsd(params_format(params))) {
+            bclk_rate = calculate_dsd_bclk(params_format(params), params_rate(params));
+            /* DSD always uses 22.579 MHz MCLK - force it if different */
+            if (mclk_rate != 22579200) {
+                dev_info(i2s_tdm->dev, "DSD: MCLK rate %u Hz, expected 22579200 Hz\n", mclk_rate);
+            }
+            dev_info(i2s_tdm->dev, "DSD mode: BCLK=%u Hz, MCLK=%u Hz\n", bclk_rate, mclk_rate);
+        } else {
+            bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+        }
+        
+        if (!bclk_rate) {
+            ret = -EINVAL;
+            goto err;
+        }
+
+        div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+        div_lrck = bclk_rate / params_rate(params);
+    }
+
+    switch (params_format(params)) {
+    case SNDRV_PCM_FORMAT_S8:
+        val |= I2S_TXCR_VDW(8);
+        /* Disable DSD-on signal for PCM formats */
+        if (i2s_tdm->dsd_on_gpio && i2s_tdm->dsd_mode_active) {
+            i2s_tdm->dsd_mode_active = false;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+            /* Apply routing for PCM mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_S16_LE:
+        val |= I2S_TXCR_VDW(16);
+        /* Disable DSD-on signal for PCM formats */
+        if (i2s_tdm->dsd_on_gpio && i2s_tdm->dsd_mode_active) {
+            i2s_tdm->dsd_mode_active = false;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+            /* Apply routing for PCM mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_S20_3LE:
+        val |= I2S_TXCR_VDW(20);
+        /* Disable DSD-on signal for PCM formats */
+        if (i2s_tdm->dsd_on_gpio && i2s_tdm->dsd_mode_active) {
+            i2s_tdm->dsd_mode_active = false;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+            /* Apply routing for PCM mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        val |= I2S_TXCR_VDW(24);
+        /* Disable DSD-on signal for PCM formats */
+        if (i2s_tdm->dsd_on_gpio && i2s_tdm->dsd_mode_active) {
+            i2s_tdm->dsd_mode_active = false;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+            /* Apply routing for PCM mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_S32_LE:
+    case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+        val |= I2S_TXCR_VDW(32);
+        /* Disable DSD-on signal for PCM formats */
+        if (i2s_tdm->dsd_on_gpio && i2s_tdm->dsd_mode_active) {
+            i2s_tdm->dsd_mode_active = false;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+            /* Apply routing for PCM mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U8:
+        val |= I2S_TXCR_VDW(8); /* DSD_U8: return standard 8-bit container */
+        
+        /* FORCE disable mmap for DSD_U8 - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD U8: mmap DISABLED, copy_user FORCED\n");
+        
+        /* Activate DSD-on signal */
+        if (i2s_tdm->dsd_on_gpio) {
+            i2s_tdm->dsd_mode_active = true;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 1);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO activated (DSD mode ON)\n");
+            /* Apply routing for DSD mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        val |= I2S_TXCR_VDW(16);
+        
+        /* FORCE disable mmap for DSD - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD U16: mmap DISABLED, copy_user FORCED\n");
+        
+        /* Activate DSD-on signal */
+        if (i2s_tdm->dsd_on_gpio) {
+            i2s_tdm->dsd_mode_active = true;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 1);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO activated (DSD mode ON)\n");
+            /* Apply routing for DSD mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U32_LE:
+    case SNDRV_PCM_FORMAT_DSD_U32_BE:
+        val |= I2S_TXCR_VDW(16); /* DSD: only 16 bits of data in 32-bit container */
+        
+        /* FORCE disable mmap for DSD - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD: mmap DISABLED, copy_user FORCED\n");
+        
+        /* Activate DSD-on signal */
+        if (i2s_tdm->dsd_on_gpio) {
+            i2s_tdm->dsd_mode_active = true;
+            gpiod_set_value(i2s_tdm->dsd_on_gpio, 1);
+            dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO activated (DSD mode ON)\n");
+            /* Apply routing for DSD mode */
+            rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        }
+        break;
+    default:
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
+    if (ret < 0)
+        goto err;
+
+    val |= ret;
+
+    /* Apply PCM channel swap if enabled and not in DSD mode */
+    if (!i2s_tdm->dsd_mode_active) {
+        unsigned int mask, ckr_val;
+        
+        mask = I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+        regmap_read(i2s_tdm->regmap, I2S_CKR, &ckr_val);
+        
+        ckr_val &= ~mask;
+        if (i2s_tdm->pcm_channel_swap) {
+            ckr_val |= I2S_CKR_TLP_INVERTED | I2S_CKR_RLP_INVERTED;
+        } else {
+            ckr_val |= I2S_CKR_TLP_NORMAL | I2S_CKR_RLP_NORMAL;
+        }
+        regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, ckr_val);
+    }
+
+    if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
+        return 0;
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_params_trcm(substream, dai, div_bclk, div_lrck, val);
+    else
+        rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
 
-//+++
-	if( s2mono && (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) ) {
-		val |= I2S_TXCR_VDW(16);
-		val |= I2S_CHN_4;
-		goto s2mono_l;
-	}
-//+++
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S8:
-		val |= I2S_TXCR_VDW(8);
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		val |= I2S_TXCR_VDW(16);
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		val |= I2S_TXCR_VDW(20);
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		val |= I2S_TXCR_VDW(24);
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
-		val |= I2S_TXCR_VDW(32);
-		break;
-	default:
-		ret = -EINVAL;
-		goto err;
-	}
-
-//+++
-	switch (params_channels(params)) {
-	case 8:
-		val |= I2S_CHN_8;
-		break;
-	case 6:
-		val |= I2S_CHN_6;
-		break;
-	case 4:
-		val |= I2S_CHN_4;
-		break;
-	case 2:
-		val |= I2S_CHN_2;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-s2mono_l:
-
-			// only TX
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_TXM(div_bclk));
-		//---
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk));
-		//---
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_TSD_MASK,
-				   I2S_CKR_TSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   val);
-
-//+++
-
-	// orig
-	if(0) {
-		ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
-		if (ret < 0)
-			goto err;
-
-		val |= ret;
-		if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
-			return 0;
-
-		if (i2s_tdm->clk_trcm)
-			rockchip_i2s_tdm_params_trcm(substream, dai, div_bclk, div_lrck, val);
-		else
-			rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
-	}
-	// orig
-
-	ret = rockchip_i2s_io_multiplex(substream, dai);
+    ret = rockchip_i2s_io_multiplex(substream, dai);
 
 err:
-	return ret;
+    return ret;
 }
 
+/* Updated trigger function */
 static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
-				    int cmd, struct snd_soc_dai *dai)
+        int cmd, struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int ret = 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int ret = 0;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
-		break;
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    /* Reset pause state on start */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_RESUME:
+    /* Reset pause state on system resume */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    /* Resume after pause */
+    rockchip_i2s_tdm_resume(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_STOP:
+    /* Reset pause state on stop */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+    /* Stream suspension */
+    rockchip_i2s_tdm_pause(i2s_tdm, substream->stream);
+    break;
+    default:
+    ret = -EINVAL;
+    break;
+    }
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
-				       unsigned int freq, int dir)
+           unsigned int freq, int dir)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    unsigned int fixed_freq;
 
-	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
-	if (i2s_tdm->clk_trcm) {
-		i2s_tdm->mclk_tx_freq = freq;
-		i2s_tdm->mclk_rx_freq = freq;
-	} else {
-		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-			i2s_tdm->mclk_tx_freq = freq;
-		else
-			i2s_tdm->mclk_rx_freq = freq;
-	}
+    /* Fix MCLK to standard frequencies for each domain with multiplier support */
+    if (freq % 44100 == 0) {
+        /* 44.1 kHz family - use 22579200 Hz (512x) or 45158400 Hz (1024x) */
+        fixed_freq = (i2s_tdm->mclk_multiplier == 1024) ? 45158400 : 22579200;
+    } else {
+        /* 48 kHz family - use 24576000 Hz (512x) or 49152000 Hz (1024x) */
+        fixed_freq = (i2s_tdm->mclk_multiplier == 1024) ? 49152000 : 24576000;
+    }
+
+    /* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+    if (i2s_tdm->clk_trcm) {
+    i2s_tdm->mclk_tx_freq = fixed_freq;
+    i2s_tdm->mclk_rx_freq = fixed_freq;
+    } else {
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->mclk_tx_freq = fixed_freq;
+    else
+        i2s_tdm->mclk_rx_freq = fixed_freq;
+    }
 
-	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
-		stream ? "rx" : "tx", freq);
+    dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d (fixed from %d)\n",
+    stream ? "rx" : "tx", fixed_freq, freq);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,
-						  struct snd_ctl_elem_info *uinfo)
+          struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = CLK_PPM_MIN;
-	uinfo->value.integer.max = CLK_PPM_MAX;
-	uinfo->value.integer.step = 1;
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = CLK_PPM_MIN;
+    uinfo->value.integer.max = CLK_PPM_MAX;
+    uinfo->value.integer.step = 1;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
+    ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	int ret = 0, ppm = 0;
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret = 0, ppm = 0;
 
-	if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
-	    (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
-		return -EINVAL;
+    if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
+        (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
+    return -EINVAL;
 
-	ppm = ucontrol->value.integer.value[0];
+    ppm = ucontrol->value.integer.value[0];
 
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
-					    i2s_tdm->mclk_root0_freq, ppm);
-	if (ret)
-		return ret;
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
+            i2s_tdm->mclk_root0_freq, ppm);
+    if (ret)
+    return ret;
 
-	if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
-		return 0;
+    if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
+    return 0;
 
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
-					    i2s_tdm->mclk_root1_freq, ppm);
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
+            i2s_tdm->mclk_root1_freq, ppm);
 
-	return ret;
+    return ret;
 }
 
 static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	.name = "PCM Clk Compensation In PPM",
-	.info = rockchip_i2s_tdm_clk_compensation_info,
-	.get = rockchip_i2s_tdm_clk_compensation_get,
-	.put = rockchip_i2s_tdm_clk_compensation_put,
-};
-
-/* loopback mode select */
-enum {
-	LOOPBACK_MODE_DIS = 0,
-	LOOPBACK_MODE_1,
-	LOOPBACK_MODE_2,
-	LOOPBACK_MODE_2_SWAP,
-};
-
-static const char *const loopback_text[] = {
-	"Disabled",
-	"Mode1",
-	"Mode2",
-	"Mode2 Swap",
-};
-
-static SOC_ENUM_SINGLE_EXT_DECL(loopback_mode, loopback_text);
-
-static int rockchip_i2s_tdm_loopback_get(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int reg = 0, mode = 0;
-
-	pm_runtime_get_sync(component->dev);
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &reg);
-	pm_runtime_put(component->dev);
-
-	switch (reg & I2S_XFER_LP_MODE_MASK) {
-	case I2S_XFER_LP_MODE_2_SWAP:
-		mode = LOOPBACK_MODE_2_SWAP;
-		break;
-	case I2S_XFER_LP_MODE_2:
-		mode = LOOPBACK_MODE_2;
-		break;
-	case I2S_XFER_LP_MODE_1:
-		mode = LOOPBACK_MODE_1;
-		break;
-	default:
-		mode = LOOPBACK_MODE_DIS;
-		break;
-	}
-
-	ucontrol->value.enumerated.item[0] = mode;
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_loopback_put(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int val = 0, mode = ucontrol->value.enumerated.item[0];
-
-	if (mode < LOOPBACK_MODE_DIS ||
-	    mode > LOOPBACK_MODE_2_SWAP)
-		return -EINVAL;
-
-	switch (mode) {
-	case LOOPBACK_MODE_2_SWAP:
-		val = I2S_XFER_LP_MODE_2_SWAP;
-		break;
-	case LOOPBACK_MODE_2:
-		val = I2S_XFER_LP_MODE_2;
-		break;
-	case LOOPBACK_MODE_1:
-		val = I2S_XFER_LP_MODE_1;
-		break;
-	default:
-		val = I2S_XFER_LP_MODE_DIS;
-		break;
-	}
-
-	pm_runtime_get_sync(component->dev);
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, I2S_XFER_LP_MODE_MASK, val);
-	pm_runtime_put(component->dev);
+    .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+    .name = "PCM Clk Compensation In PPM",
+    .info = rockchip_i2s_tdm_clk_compensation_info,
+    .get = rockchip_i2s_tdm_clk_compensation_get,
+    .put = rockchip_i2s_tdm_clk_compensation_put,
+};
 
-	return 0;
-}
+/* Loopback mode functions and definitions removed - not needed for audiophile use */
 
 static const struct snd_kcontrol_new rockchip_i2s_tdm_snd_controls[] = {
-	SOC_ENUM_EXT("I2STDM Digital Loopback Mode", loopback_mode,
-		     rockchip_i2s_tdm_loopback_get,
-		     rockchip_i2s_tdm_loopback_put),
+    /* Loopback Mode control removed - not needed for audiophile use */
 };
 
+/* Control structures defined after functions */
+
+/* Audiophile ALSA controls */
+static int rockchip_i2s_tdm_volume_info(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_volume_get(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    ucontrol->value.integer.value[0] = i2s_tdm->volume;
+    return 0;
+}
+
+/* Updated volume setting function */
+static int rockchip_i2s_tdm_volume_put(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int volume = ucontrol->value.integer.value[0];
+    int old_volume = i2s_tdm->volume;
+    int old_linear = 0, new_linear = 0;
+    int ratio_x1000 = 0; /* Ratio * 1000 to avoid float */
+
+    if (volume < 0 || volume > 100)
+        return -EINVAL;
+
+    if (volume == old_volume)
+        return 0;
+
+    /* Save old value for comparison */
+    if (i2s_tdm->audio_proc) {
+        old_linear = i2s_tdm->audio_proc->volume_linear_q16;
+    }
+
+    i2s_tdm->volume = volume;
+    
+    /* Update audiophile processing */
+    rockchip_audiophile_update_volume(i2s_tdm);
+    
+    /* Get new value */
+    if (i2s_tdm->audio_proc) {
+        new_linear = i2s_tdm->audio_proc->volume_linear_q16;
+    }
+    
+    /* Calculate ratio without float */
+    if (old_linear > 0 && new_linear > 0) {
+        ratio_x1000 = (new_linear * 1000) / old_linear;
+    }
+    
+    /* Detailed transition information */
+    dev_info(i2s_tdm->dev, "Volume: %d%% -> %d%% | Linear: 0x%x (%d) -> 0x%x (%d) | Ratio x1000: %d\n", 
+             old_volume, volume, 
+             old_linear, old_linear, 
+             new_linear, new_linear,
+             ratio_x1000);
+    
+    /* Check for large jumps (ratio less than 0.5 or greater than 2.0) */
+    if (old_linear > 0 && new_linear > 0) {
+        if (ratio_x1000 < 500 || ratio_x1000 > 2000) {
+            dev_warn(i2s_tdm->dev, "WARNING: Large volume jump detected! Ratio x1000: %d\n", ratio_x1000);
+        }
+    }
+    
+    return 1;
+}
+
+static int rockchip_i2s_tdm_mute_info(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    /* Invert value for player: mute=false -> return 1 (unmute) */
+    ucontrol->value.integer.value[0] = !i2s_tdm->mute;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    bool mute_request = ucontrol->value.integer.value[0];
+    
+    /* Invert logic: player passes 1=unmute, 0=mute */
+    bool mute = !mute_request;
+
+    if (i2s_tdm->mute == mute)
+        return 0;
+
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    i2s_tdm->mute = mute;
+
+    if (mute) {
+        /* User enabled mute - set priority */
+        i2s_tdm->user_mute_priority = true;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_pre_work);
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Enable mute instantly */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+        
+    } else {
+        /* User disabled mute - reset priority */
+        i2s_tdm->user_mute_priority = false;
+        i2s_tdm->auto_mute_active = false;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_pre_work);
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Disable mute */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, false);
+        dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Mute disabled by user control (priority cleared)\n");
+    }
+
+    mutex_unlock(&i2s_tdm->mute_lock);
+    
+    /* Notify ALSA about mute state change for synchronization with alsamixer */
+    if (i2s_tdm->mute_kcontrol && i2s_tdm->dai && i2s_tdm->dai->component) {
+        snd_ctl_notify(i2s_tdm->dai->component->card->snd_card, SNDRV_CTL_EVENT_MASK_VALUE, &i2s_tdm->mute_kcontrol->id);
+    }
+    
+    return 1; /* Return 1 to notify ALSA of change */
+}
+
+/* Automatic mute during switching */
+static void rockchip_i2s_tdm_apply_mute(struct rk_i2s_tdm_dev *i2s_tdm, bool enable)
+{
+    unsigned long flags;
+    
+    if (enable) {
+        /* Enable mute INSTANTLY - premute_delay_ms already processed before call */
+        if (i2s_tdm->mute_gpio)
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        
+        /* Software mute through volume = 0% for DACs without GPIO mute */
+        /* Always apply - DSD copy_user will check and replace with silence */
+        if (i2s_tdm->audio_proc) {
+            spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+            i2s_tdm->audio_proc->volume_linear_q16 = 0;  /* Complete silence */
+            spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+        }
+        
+        /* DO NOT disable DMA - this leads to pause instead of mute */
+        /* DMA continues to work, but sound is muted through GPIO + software */
+        
+    } else {
+        /* Disable mute instantly - delay was already in delayed_work */
+        if (i2s_tdm->mute_gpio) {
+            gpiod_set_value(i2s_tdm->mute_gpio, 0);
+        }
+        
+        /* Restore software volume */
+        /* Always apply - DSD copy_user will replace with correct signal anyway */
+        if (i2s_tdm->audio_proc) {
+            spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+            /* Restore volume from current i2s_tdm->volume setting */
+            if (i2s_tdm->volume >= 0 && i2s_tdm->volume <= 100) {
+                i2s_tdm->audio_proc->volume_linear_q16 = volume_linear_table[i2s_tdm->volume];
+            } else {
+                i2s_tdm->audio_proc->volume_linear_q16 = 65536; /* 100% */
+            }
+            spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+        }
+        
+        /* DMA is already working, mute lifted through GPIO + software */
+    }
+}
+
+/* Function for pre-mute work thread (enable 20ms before) */
+static void rockchip_i2s_tdm_mute_pre_work(struct work_struct *work)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = container_of(work, struct rk_i2s_tdm_dev, mute_pre_work.work);
+    
+    /* Check that device is still active */
+    if (!i2s_tdm->dev || !device_is_registered(i2s_tdm->dev)) {
+        dev_warn(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Device unregistered during pre-mute work\n");
+        return;
+    }
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    /* Enable automatic mute only if no user priority */
+    if (!i2s_tdm->user_mute_priority) {
+        i2s_tdm->auto_mute_active = true;
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+    }
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+}
+
+/* Function for post-mute work thread (disable after 400ms) */
+static void rockchip_i2s_tdm_mute_post_work(struct work_struct *work)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = container_of(work, struct rk_i2s_tdm_dev, mute_post_work.work);
+    
+    /* Check that device is still active */
+    if (!i2s_tdm->dev || !device_is_registered(i2s_tdm->dev)) {
+        dev_warn(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Device unregistered during post-mute work\n");
+        return;
+    }
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    /* Disable automatic mute only if it was active and no user priority */
+    if (i2s_tdm->auto_mute_active && !i2s_tdm->user_mute_priority) {
+        i2s_tdm->auto_mute_active = false;
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, false);
+    }
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+}
+
+/* Function to start automatic mute during switching */
+static void rockchip_i2s_tdm_trigger_auto_mute(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    unsigned long current_time = jiffies;
+    unsigned long min_interval = msecs_to_jiffies(AUTOMUTE_DEBOUNCE_MS); // minimum interval
+    bool is_atomic_ctx = in_atomic() || in_interrupt() || irqs_disabled();
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    /* Check if auto-mute is called too frequently */
+    if (i2s_tdm->last_auto_mute_time != 0 && 
+        time_before(current_time, i2s_tdm->last_auto_mute_time + min_interval)) {
+        /* Too frequent calls - just extend existing mute */
+        dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Auto-mute debounce - extending existing mute\n");
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        schedule_delayed_work(&i2s_tdm->mute_post_work, msecs_to_jiffies(i2s_tdm->postmute_delay_ms));
+        mutex_unlock(&i2s_tdm->mute_lock);
+        return;
+    }
+    
+    /* Update last trigger time */
+    i2s_tdm->last_auto_mute_time = current_time;
+    
+    /* Cancel any previous post-mute timers */
+    cancel_delayed_work(&i2s_tdm->mute_post_work);
+    
+    /* CRITICAL: Enable GPIO mute INSTANTLY first */
+    if (!i2s_tdm->user_mute_priority) {
+        if (i2s_tdm->mute_gpio) {
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        }
+        
+        /* Enable software mute instantly */
+        i2s_tdm->auto_mute_active = true;
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+        
+        /* Premute delay depends on context */
+        if (i2s_tdm->premute_delay_ms > 0) {
+            if (is_atomic_ctx) {
+                /* In atomic context - only short delays via udelay */
+                if (i2s_tdm->premute_delay_ms <= 10) {
+                    udelay(i2s_tdm->premute_delay_ms * 1000);
+                }
+                /* Skip long delays - mute already enabled */
+                dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Atomic context - skipping long premute delay\n");
+            } else {
+                /* In normal context - can use mdelay */
+                if (i2s_tdm->premute_delay_ms >= 10) {
+                    mdelay(i2s_tdm->premute_delay_ms);
+                } else {
+                    udelay(i2s_tdm->premute_delay_ms * 1000);
+                }
+            }
+        }
+    }
+    
+    /* Start post-mute after configurable time */
+    if (i2s_tdm->postmute_delay_ms > 0)
+        schedule_delayed_work(&i2s_tdm->mute_post_work, msecs_to_jiffies(i2s_tdm->postmute_delay_ms));
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+}
+
+/* Function to enable mute when stopping playback WITHOUT automatic disable */
+static void rockchip_i2s_tdm_trigger_stop_mute(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    bool is_atomic_ctx = in_atomic() || in_interrupt() || irqs_disabled();
+    
+    /* Attempt non-blocking lock in atomic context */
+    if (is_atomic_ctx) {
+        if (!mutex_trylock(&i2s_tdm->mute_lock)) {
+            /* If failed - do only critical operations without locking */
+            dev_warn(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Atomic context - direct GPIO mute without lock\n");
+            if (i2s_tdm->mute_gpio && !i2s_tdm->user_mute_priority) {
+                gpiod_set_value(i2s_tdm->mute_gpio, 1);
+            }
+            return;
+        }
+    } else {
+        mutex_lock(&i2s_tdm->mute_lock);
+    }
+    
+    /* Cancel any previous post-mute timers */
+    cancel_delayed_work(&i2s_tdm->mute_post_work);
+    
+    /* CRITICAL: Enable GPIO mute PHYSICALLY before stopping data */
+    if (!i2s_tdm->user_mute_priority) {
+        /* Enable GPIO mute INSTANTLY - this is fastest */
+        if (i2s_tdm->mute_gpio) {
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        }
+        
+        /* Premute delay only for very short intervals when stopping */
+        if (i2s_tdm->premute_delay_ms > 0 && i2s_tdm->premute_delay_ms <= 5) {
+            udelay(i2s_tdm->premute_delay_ms * 1000);
+        }
+        /* Skip long delays when stopping - mute already enabled via GPIO */
+        
+        i2s_tdm->auto_mute_active = true;
+        /* Also enable software mute for compatibility */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+    }
+    
+    /* DO NOT start post-mute timer - mute stays enabled until next start */
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+}
+
+/* MCLK multiplier sysfs interface */
+static ssize_t mclk_multiplier_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->mclk_multiplier);
+}
+
+static ssize_t mclk_multiplier_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int multiplier;
+    
+    if (sscanf(buf, "%d", &multiplier) != 1)
+        return -EINVAL;
+    
+    if (multiplier != 512 && multiplier != 1024) {
+        dev_err(dev, "Invalid MCLK multiplier: %d. Must be 512 or 1024.\n", multiplier);
+        return -EINVAL;
+    }
+    
+    i2s_tdm->mclk_multiplier = multiplier;
+    dev_info(dev, "MCLK multiplier set to %dx\n", multiplier);
+    
+    return count;
+}
+
+static DEVICE_ATTR(mclk_multiplier, 0644, mclk_multiplier_show, mclk_multiplier_store);
+
+/* DSD channel swap sysfs interface */
+
+static ssize_t dsd_sample_swap_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->dsd_sample_swap ? 1 : 0);
+}
+
+static ssize_t dsd_sample_swap_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    i2s_tdm->dsd_sample_swap = enable ? true : false;
+    dev_info(dev, "DSD Sample Swap to eliminate purple noise %s\n", 
+             enable ? "ENABLED" : "DISABLED");
+    
+    return count;
+}
+
+static DEVICE_ATTR(dsd_sample_swap, 0644, dsd_sample_swap_show, dsd_sample_swap_store);
+
+static ssize_t pcm_channel_swap_show(struct device *dev,
+                                    struct device_attribute *attr,
+                                    char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->pcm_channel_swap ? 1 : 0);
+}
+
+static ssize_t pcm_channel_swap_store(struct device *dev,
+                                     struct device_attribute *attr,
+                                     const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    /* Accept only 0 or 1 */
+    if (enable != 0 && enable != 1)
+        return -EINVAL;
+    
+    i2s_tdm->pcm_channel_swap = (enable == 1);
+    
+    dev_info(dev, "PCM Channel Swap (LRCK inversion) %s\n", 
+             enable ? "ENABLED" : "DISABLED");
+    
+    /* Changes will apply on next playback */
+    
+    return count;
+}
+
+static DEVICE_ATTR(pcm_channel_swap, 0644, pcm_channel_swap_show, pcm_channel_swap_store);
+
+static ssize_t dsd_physical_swap_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->dsd_physical_swap ? 1 : 0);
+}
+
+static ssize_t dsd_physical_swap_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    i2s_tdm->dsd_physical_swap = enable ? true : false;
+    dev_info(dev, "DSD Physical Channel Swap %s\n", 
+             enable ? "enabled" : "disabled");
+    
+    /* FIX: Apply routing changes ONLY for current DSD mode */
+    if (i2s_tdm->dsd_mode_active) {
+        /* If DSD mode is active - apply swap immediately */
+        rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        dev_info(dev, "DSD Physical Channel Swap applied immediately (DSD mode active)\n");
+    } else {
+        /* If PCM mode - only save setting, will be applied when switching to DSD */
+        dev_info(dev, "DSD Physical Channel Swap setting saved (will apply in DSD mode)\n");
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(dsd_physical_swap, 0644, dsd_physical_swap_show, dsd_physical_swap_store);
+
+/* Premute delay sysfs interface */
+static ssize_t premute_delay_ms_show(struct device *dev,
+                                    struct device_attribute *attr,
+                                    char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", i2s_tdm->premute_delay_ms);
+}
+
+static ssize_t premute_delay_ms_store(struct device *dev,
+                                     struct device_attribute *attr,
+                                     const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    unsigned int delay;
+
+    if (kstrtouint(buf, 10, &delay) || delay > 1000)
+        return -EINVAL;
+
+    i2s_tdm->premute_delay_ms = delay;
+    dev_info(i2s_tdm->dev, "Premute delay set to %u ms", delay);
+
+    return count;
+}
+
+static DEVICE_ATTR(premute_delay_ms, 0644, premute_delay_ms_show, premute_delay_ms_store);
+
+/* Postmute delay sysfs interface */
+static ssize_t postmute_delay_ms_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", i2s_tdm->postmute_delay_ms);
+}
+
+static ssize_t postmute_delay_ms_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    unsigned int delay;
+
+    if (kstrtouint(buf, 10, &delay) || delay > 2000)
+        return -EINVAL;
+
+    i2s_tdm->postmute_delay_ms = delay;
+    dev_info(i2s_tdm->dev, "Postmute delay set to %u ms", delay);
+
+    return count;
+}
+
+static DEVICE_ATTR(postmute_delay_ms, 0644, postmute_delay_ms_show, postmute_delay_ms_store);
+
+/* Mute control sysfs interface */
+static ssize_t mute_show(struct device *dev,
+                        struct device_attribute *attr,
+                        char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->mute ? 1 : 0);
+}
+
+static ssize_t mute_store(struct device *dev,
+                         struct device_attribute *attr,
+                         const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    /* Accept only 0 or 1 */
+    if (enable != 0 && enable != 1)
+        return -EINVAL;
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    if (enable && !i2s_tdm->mute) {
+        /* Enable mute */
+        i2s_tdm->mute = true;
+        i2s_tdm->user_mute_priority = true;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_pre_work);
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Enable mute instantly */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+        
+    } else if (!enable && i2s_tdm->mute) {
+        /* Disable mute */
+        i2s_tdm->mute = false;
+        i2s_tdm->user_mute_priority = false;
+        i2s_tdm->auto_mute_active = false;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_pre_work);
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Disable mute */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, false);
+    }
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+    
+    /* Notify ALSA about mute state change for synchronization with alsamixer */
+    if (i2s_tdm->mute_kcontrol && i2s_tdm->dai && i2s_tdm->dai->component) {
+        snd_ctl_notify(i2s_tdm->dai->component->card->snd_card, SNDRV_CTL_EVENT_MASK_VALUE, &i2s_tdm->mute_kcontrol->id);
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(mute, 0644, mute_show, mute_store);
+
+/* Dithering control */
+static int rockchip_i2s_tdm_dither_info(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_dither_get(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    
+    if (i2s_tdm->audio_proc)
+        ucontrol->value.integer.value[0] = i2s_tdm->audio_proc->dither_enabled;
+    else
+        ucontrol->value.integer.value[0] = 0;
+    
+    return 0;
+}
+
+static int rockchip_i2s_tdm_dither_put(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    bool dither_enable = !!ucontrol->value.integer.value[0];
+    unsigned long flags;
+    
+    if (!i2s_tdm->audio_proc)
+        return -ENODEV;
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    
+    if (i2s_tdm->audio_proc->dither_enabled != dither_enable) {
+        i2s_tdm->audio_proc->dither_enabled = dither_enable;
+        /* Update PRNG state */
+        if (dither_enable) {
+            get_random_bytes(i2s_tdm->audio_proc->dither_state, 
+                           sizeof(i2s_tdm->audio_proc->dither_state));
+        }
+        spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+        
+        dev_info(i2s_tdm->dev, "Audiophile: Dithering %s\n", 
+                 dither_enable ? "enabled" : "disabled");
+        return 1;
+    }
+    
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    return 0;
+}
+
+
+/* Processing statistics control */
+static int rockchip_i2s_tdm_stats_info(struct snd_kcontrol *kcontrol,
+                                      struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER64;
+    uinfo->count = 3; // samples_processed, peak_level, clipping_detected
+    return 0;
+}
+
+static int rockchip_i2s_tdm_stats_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    unsigned long flags;
+    
+    if (!i2s_tdm->audio_proc) {
+        memset(ucontrol->value.integer64.value, 0, sizeof(long long) * 3);
+        return 0;
+    }
+    
+    spin_lock_irqsave(&i2s_tdm->audio_proc_lock, flags);
+    ucontrol->value.integer64.value[0] = i2s_tdm->audio_proc->samples_processed;
+    ucontrol->value.integer64.value[1] = i2s_tdm->audio_proc->peak_level;
+    ucontrol->value.integer64.value[2] = i2s_tdm->audio_proc->clipping_detected ? 1 : 0;
+    spin_unlock_irqrestore(&i2s_tdm->audio_proc_lock, flags);
+    
+    return 0;
+}
+
+/* Main ALSA controls */
+static struct snd_kcontrol_new rockchip_i2s_tdm_volume_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Volume",
+    .info = rockchip_i2s_tdm_volume_info,
+    .get = rockchip_i2s_tdm_volume_get,
+    .put = rockchip_i2s_tdm_volume_put,
+};
+
+static struct snd_kcontrol_new rockchip_i2s_tdm_mute_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Switch",
+    .info = rockchip_i2s_tdm_mute_info,
+    .get = rockchip_i2s_tdm_mute_get,
+    .put = rockchip_i2s_tdm_mute_put,
+};
+
+/* Additional audiophile controls */
+static struct snd_kcontrol_new rockchip_i2s_tdm_audiophile_controls[] = {
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+        .name = "Audiophile Dithering",
+        .info = rockchip_i2s_tdm_dither_info,
+        .get = rockchip_i2s_tdm_dither_get,
+        .put = rockchip_i2s_tdm_dither_put,
+    },
+    {
+        .iface = SNDRV_CTL_ELEM_IFACE_MIXER,  
+        .name = "Audiophile Statistics",
+        .access = SNDRV_CTL_ELEM_ACCESS_READ,
+        .info = rockchip_i2s_tdm_stats_info,
+        .get = rockchip_i2s_tdm_stats_get,
+    },
+};
+
+/* PCM copy callback for audio data processing */
+static int rockchip_i2s_tdm_pcm_copy_user(struct snd_soc_component *component,
+                                          struct snd_pcm_substream *substream,
+                                          int channel, unsigned long pos,
+                                          void __user *buf, unsigned long bytes)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    void *dma_area;
+    int ret;
+    static int copy_call_count = 0;
+    static bool bypass_processing = false; /* For testing without processing */
+    
+    /* Get our driver through component */
+    i2s_tdm = snd_soc_component_get_drvdata(component);
+    if (!i2s_tdm) {
+        /* Debug message only for first calls */
+        if (copy_call_count < 3) {
+            dev_warn(component->dev, "Failed to get I2S TDM device from component (call %d)\n", copy_call_count++);
+        }
+        /* Fallback: standard copying without processing */
+        dma_area = substream->runtime->dma_area + pos;
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            return copy_from_user(dma_area, buf, bytes) ? -EFAULT : 0;
+        } else {
+            return copy_to_user(buf, dma_area, bytes) ? -EFAULT : 0;
+        }
+    }
+    
+    /* Get pointer to DMA buffer */
+    dma_area = substream->runtime->dma_area + pos;
+    if (!dma_area) {
+        dev_err(component->dev, "Invalid DMA area\n");
+        return -EINVAL;
+    }
+    
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        /* PLAYBACK: copy from user and process */
+        if (copy_from_user(dma_area, buf, bytes))
+            return -EFAULT;
+        
+        /* DSD MUTE: Replace data with silence signal (50% duty cycle) */
+        if (i2s_tdm->mute && i2s_tdm->dsd_mode_active &&
+            (substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_LE || 
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_BE ||
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U16_LE) && 
+            bytes >= 4) {
+            
+            /* For DSD silence = alternating 0 and 1 (50% duty cycle) */
+            uint8_t *data = (uint8_t *)dma_area;
+            uint32_t i;
+            
+            for (i = 0; i < bytes; i++) {
+                data[i] = (i & 1) ? 0xFF : 0x00;  /* Alternating 00000000 and 11111111 */
+            }
+            
+            dev_dbg(i2s_tdm->dev, "DSD Mute: replaced %lu bytes with silence signal\n", bytes);
+            
+            /* During mute do not apply sample swap - send clean silence signal */
+            goto skip_dsd_processing;
+        }
+        
+        /* CRITICAL FIX FOR DSD: Swap upper and lower 16 bits */
+        if (i2s_tdm->dsd_sample_swap && i2s_tdm->dsd_mode_active &&
+            (substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_LE || 
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_BE) && 
+            bytes >= 4 && (bytes % 4) == 0) {
+            
+            uint32_t *samples = (uint32_t *)dma_area;
+            uint32_t total_samples = bytes / 4;
+            uint32_t i;
+            
+            for (i = 0; i < total_samples; i++) {
+                /* Swap upper and lower 16 bits: ABCD -> CDAB */
+                uint32_t sample = samples[i];
+                samples[i] = ((sample & 0xFFFF0000) >> 16) | ((sample & 0x0000FFFF) << 16);
+            }
+            
+            /* dev_dbg(i2s_tdm->dev, "DSD Purple Noise Fix: processed %u samples (%lu bytes)\n", 
+                     total_samples, bytes); */
+        }
+        
+    skip_dsd_processing:
+        /* Debug message only for first calls */
+        if (copy_call_count < 3) {
+            dev_info(i2s_tdm->dev, "PCM copy: %lu bytes, processor: %s, bypass: %s (call %d)\n", 
+                     bytes, 
+                     i2s_tdm->audio_proc ? "READY" : "NOT_READY",
+                     bypass_processing ? "YES" : "NO",
+                     copy_call_count++);
+        } else if (copy_call_count == 3) {
+            dev_info(i2s_tdm->dev, "PCM copy working, suppressing further debug messages\n");
+            copy_call_count++;
+        }
+        
+        /* Apply audiophile processing only if processor is initialized and bypass is disabled */
+        if (i2s_tdm->audio_proc && !bypass_processing && 
+            (i2s_tdm->volume != 100 || i2s_tdm->mute)) {
+            ret = rockchip_audiophile_process_buffer(i2s_tdm, dma_area, bytes);
+            if (ret < 0) {
+                dev_warn_ratelimited(i2s_tdm->dev, "Audio processing failed: %d\n", ret);
+                /* Do not return error, continue without processing */
+            }
+        }
+        
+        dev_dbg(i2s_tdm->dev, "Processed %lu bytes for playback\n", bytes);
+    } else {
+        /* CAPTURE: simply copy to user */
+        if (copy_to_user(buf, dma_area, bytes))
+            return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/* DSD rates for RoonReady compatibility */
+static const unsigned int dsd_rates[] = {
+    2822400,   /* DSD64 */
+    5644800,   /* DSD128 */
+    11289600,  /* DSD256 */
+    22579200,  /* DSD512 */
+};
+
+/* Add pause/resume support to PCM hardware */
+static const struct snd_pcm_hardware rockchip_i2s_tdm_pcm_hardware = {
+    .info = SNDRV_PCM_INFO_MMAP |
+    SNDRV_PCM_INFO_MMAP_VALID |
+    SNDRV_PCM_INFO_INTERLEAVED |
+    SNDRV_PCM_INFO_PAUSE |        /* Pause support */
+    SNDRV_PCM_INFO_RESUME |       /* Resume support */
+    SNDRV_PCM_INFO_BLOCK_TRANSFER,
+    .formats = SNDRV_PCM_FMTBIT_S8 |
+       SNDRV_PCM_FMTBIT_S16_LE |
+       SNDRV_PCM_FMTBIT_S20_3LE |
+       SNDRV_PCM_FMTBIT_S24_LE |
+       SNDRV_PCM_FMTBIT_S32_LE |
+       SNDRV_PCM_FMTBIT_DSD_U16_LE |
+       SNDRV_PCM_FMTBIT_DSD_U32_LE,
+    .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+    .rate_min = 8000,
+    .rate_max = 22579200,  /* DSD512 support (22.5792 MHz) */
+    .channels_min = 2,
+    .channels_max = 16,
+    .buffer_bytes_max = 512 * 1024,
+    .period_bytes_min = 64,
+    .period_bytes_max = 64 * 1024,
+    .periods_min = 2,
+    .periods_max = 512,
+    .fifo_size = 16,
+};
+
+static const struct snd_dmaengine_pcm_config rockchip_i2s_tdm_dmaengine_pcm_config = {
+    .pcm_hardware = &rockchip_i2s_tdm_pcm_hardware,
+    .prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+    .prealloc_buffer_size = 512 * 1024,
+};
+
+/* Component probe function to set driver data */
+static int rockchip_i2s_tdm_component_probe(struct snd_soc_component *component)
+{
+    struct device *dev = component->dev;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    
+    /* Get our driver from platform device */
+    i2s_tdm = dev_get_drvdata(dev);
+    if (!i2s_tdm) {
+        dev_err(dev, "Failed to get I2S TDM device data in component probe\n");
+        return -ENODEV;
+    }
+    
+    /* Set driver data for component */
+    snd_soc_component_set_drvdata(component, i2s_tdm);
+    
+    dev_info(dev, "Audiophile component probe: driver data set successfully\n");
+    
+    return 0;
+}
+
+/* Alternative way through ioctl for older ALSA versions */
+static int rockchip_i2s_tdm_pcm_ioctl(struct snd_soc_component *component,
+                                      struct snd_pcm_substream *substream,
+                                      unsigned int cmd, void *arg)
+{
+    /* Standard ioctl without additional processing */
+    return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+/* Component with copy callbacks support */
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component_with_copy = {
+    .name = DRV_NAME,
+    .probe = rockchip_i2s_tdm_component_probe,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
+    .copy_user = rockchip_i2s_tdm_pcm_copy_user,
+    .ioctl = rockchip_i2s_tdm_pcm_ioctl,
+};
+
+/* Updated probe function with audiophile functions initialization */
 static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret;
 
-	dai->capture_dma_data = &i2s_tdm->capture_dma_data;
-	dai->playback_dma_data = &i2s_tdm->playback_dma_data;
+    dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+    dai->playback_dma_data = &i2s_tdm->playback_dma_data;
 
-	if (i2s_tdm->mclk_calibrate)
-		snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+    /* Initialize audiophile processing */
+    ret = rockchip_audiophile_init(i2s_tdm);
+    if (ret) {
+        dev_err(i2s_tdm->dev, "Failed to initialize audiophile processor: %d\n", ret);
+        return ret;
+    }
+    
+    /* Initialize volume */
+    rockchip_audiophile_update_volume(i2s_tdm);
+    dev_info(i2s_tdm->dev, "Audiophile processing enabled with copy callbacks\n");
+
+    if (i2s_tdm->mclk_calibrate) {
+        ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+        if (ret)
+            dev_err(i2s_tdm->dev, "Failed to add compensation control: %d\n", ret);
+    }
+
+    /* Main controls */
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_volume_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add volume control: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Audiophile volume control added successfully\n");
+
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_mute_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add mute control: %d\n", ret);
+    else {
+        dev_info(i2s_tdm->dev, "Audiophile mute control added successfully\n");
+        /* Save pointers for sysfs synchronization */
+        i2s_tdm->mute_kcontrol = snd_soc_card_get_kcontrol(dai->component->card, rockchip_i2s_tdm_mute_control.name);
+        i2s_tdm->dai = dai;
+    }
+
+    /* Audiophile controls */
+    ret = snd_soc_add_dai_controls(dai, rockchip_i2s_tdm_audiophile_controls,
+                                  ARRAY_SIZE(rockchip_i2s_tdm_audiophile_controls));
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add audiophile controls: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Audiophile controls added successfully\n");
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
-				 unsigned int tx_mask, unsigned int rx_mask,
-				 int slots, int slot_width)
+     unsigned int tx_mask, unsigned int rx_mask,
+     int slots, int slot_width)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	unsigned int mask, val;
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    unsigned int mask, val;
 
-	i2s_tdm->tdm_mode = true;
-	i2s_tdm->bclk_fs = slots * slot_width;
-	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
-	val = TDM_SLOT_BIT_WIDTH(slot_width) |
-	      TDM_FRAME_WIDTH(slots * slot_width);
-	pm_runtime_get_sync(dai->dev);
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-			   mask, val);
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-			   mask, val);
-	pm_runtime_put(dai->dev);
+    i2s_tdm->tdm_mode = true;
+    i2s_tdm->bclk_fs = slots * slot_width;
+    mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+    val = TDM_SLOT_BIT_WIDTH(slot_width) |
+          TDM_FRAME_WIDTH(slots * slot_width);
+
+    pm_runtime_get_sync(dai->dev);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, val);
+    pm_runtime_put(dai->dev);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_startup(struct snd_pcm_substream *substream,
-				    struct snd_soc_dai *dai)
+        struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    if (i2s_tdm->substreams[substream->stream])
+    return -EBUSY;
 
-	if (i2s_tdm->substreams[substream->stream])
-		return -EBUSY;
+    i2s_tdm->substreams[substream->stream] = substream;
 
-	i2s_tdm->substreams[substream->stream] = substream;
+    /* Export DSD rates for userspace applications like RoonReady */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        dev_info(i2s_tdm->dev, "DSD support available: 2.8M, 5.6M, 11.2M, 22.5M Hz\n");
+    }
 
-	return 0;
+    return 0;
 }
 
 static void rockchip_i2s_tdm_shutdown(struct snd_pcm_substream *substream,
-				      struct snd_soc_dai *dai)
+          struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	i2s_tdm->substreams[substream->stream] = NULL;
+    i2s_tdm->substreams[substream->stream] = NULL;
 }
 
 static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
-	.startup = rockchip_i2s_tdm_startup,
-	.shutdown = rockchip_i2s_tdm_shutdown,
-	.hw_params = rockchip_i2s_tdm_hw_params,
-	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
-	.set_fmt = rockchip_i2s_tdm_set_fmt,
-	.set_tdm_slot = rockchip_dai_tdm_slot,
-	.trigger = rockchip_i2s_tdm_trigger,
+    .startup = rockchip_i2s_tdm_startup,
+    .shutdown = rockchip_i2s_tdm_shutdown,
+    .hw_params = rockchip_i2s_tdm_hw_params,
+    .set_sysclk = rockchip_i2s_tdm_set_sysclk,
+    .set_fmt = rockchip_i2s_tdm_set_fmt,
+    .set_tdm_slot = rockchip_dai_tdm_slot,
+    .trigger = rockchip_i2s_tdm_trigger,
 };
 
 static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
-	.name = DRV_NAME,
-	.controls = rockchip_i2s_tdm_snd_controls,
-	.num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
+    .name = DRV_NAME,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
 };
 
 static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_TXFIFOLR:
-	case I2S_INTSR:
-	case I2S_RXFIFOLR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_TXFIFOLR:
+    case I2S_INTSR:
+    case I2S_RXFIFOLR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXFIFOLR:
-	case I2S_INTCR:
-	case I2S_INTSR:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_RXFIFOLR:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXFIFOLR:
+    case I2S_INTCR:
+    case I2S_INTSR:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_RXFIFOLR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_RXDR:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_RXDR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
-	{0x00, 0x7200000f},
-	{0x04, 0x01c8000f},
-	{0x08, 0x00001f1f},
-	{0x10, 0x001f0000},
-	{0x14, 0x01f00000},
-	{0x30, 0x00003eff},
-	{0x34, 0x00003eff},
-	{0x38, 0x00000707},
+    {0x00, 0x7200000f},
+    {0x04, 0x01c8000f},
+    {0x08, 0x00001f1f},
+    {0x10, 0x001f0000},
+    {0x14, 0x01f00000},
+    {0x30, 0x00003eff},
+    {0x34, 0x00003eff},
+    {0x38, 0x00000707},
 };
 
 static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = I2S_CLKDIV,
-	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
-	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
-	.writeable_reg = rockchip_i2s_tdm_wr_reg,
-	.readable_reg = rockchip_i2s_tdm_rd_reg,
-	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
-	.precious_reg = rockchip_i2s_tdm_precious_reg,
-	.cache_type = REGCACHE_FLAT,
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = I2S_CLKDIV,
+    .reg_defaults = rockchip_i2s_tdm_reg_defaults,
+    .num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+    .writeable_reg = rockchip_i2s_tdm_wr_reg,
+    .readable_reg = rockchip_i2s_tdm_rd_reg,
+    .volatile_reg = rockchip_i2s_tdm_volatile_reg,
+    .precious_reg = rockchip_i2s_tdm_precious_reg,
+    .cache_type = REGCACHE_FLAT,
 };
 
 static int common_soc_init(struct device *dev, u32 addr)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
-	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
-	int i;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	switch (trcm) {
-	case I2S_CKR_TRCM_TXONLY:
-	case I2S_CKR_TRCM_RXONLY:
-		break;
-	default:
-		return 0;
-	}
-
-	for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
-		if (addr != configs[i].addr)
-			continue;
-		reg = configs[i].reg;
-		if (trcm == I2S_CKR_TRCM_TXONLY)
-			val = configs[i].txonly;
-		else
-			val = configs[i].rxonly;
-
-		if (reg)
-			regmap_write(i2s_tdm->grf, reg, val);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    const struct txrx_config *configs = i2s_tdm->soc_data->configs;
+    u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
+    int i;
+
+    if (IS_ERR(i2s_tdm->grf))
+    return 0;
+
+    switch (trcm) {
+    case I2S_CKR_TRCM_TXONLY:
+    case I2S_CKR_TRCM_RXONLY:
+    break;
+    default:
+    return 0;
+    }
+
+    for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
+    if (addr != configs[i].addr)
+        continue;
+    reg = configs[i].reg;
+    if (trcm == I2S_CKR_TRCM_TXONLY)
+        val = configs[i].txonly;
+    else
+        val = configs[i].rxonly;
+
+    if (reg)
+        regmap_write(i2s_tdm->grf, reg, val);
+    }
 
-	return 0;
+    return 0;
 }
 
 static const struct txrx_config px30_txrx_config[] = {
-	{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
+    { 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk1808_txrx_config[] = {
-	{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
+    { 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3308_txrx_config[] = {
-	{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
-	{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
+    { 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
+    { 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3568_txrx_config[] = {
-	{ 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
-	{ 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
-	{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
+    { 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
+    { 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
+    { 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
 };
 
 static const struct txrx_config rv1126_txrx_config[] = {
-	{ 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
+    { 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
 };
 
 static const struct rk_i2s_soc_data px30_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = px30_txrx_config,
-	.config_count = ARRAY_SIZE(px30_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = px30_txrx_config,
+    .config_count = ARRAY_SIZE(px30_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk1808_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rk1808_txrx_config,
-	.config_count = ARRAY_SIZE(rk1808_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = rk1808_txrx_config,
+    .config_count = ARRAY_SIZE(rk1808_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3308_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.grf_reg_offset = 0x0308,
-	.grf_shift = 5,
-	.configs = rk3308_txrx_config,
-	.config_count = ARRAY_SIZE(rk3308_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0400,
+    .grf_reg_offset = 0x0308,
+    .grf_shift = 5,
+    .configs = rk3308_txrx_config,
+    .config_count = ARRAY_SIZE(rk3308_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3568_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.configs = rk3568_txrx_config,
-	.config_count = ARRAY_SIZE(rk3568_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0400,
+    .configs = rk3568_txrx_config,
+    .config_count = ARRAY_SIZE(rk3568_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rv1126_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rv1126_txrx_config,
-	.config_count = ARRAY_SIZE(rv1126_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = rv1126_txrx_config,
+    .config_count = ARRAY_SIZE(rv1126_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct of_device_id rockchip_i2s_tdm_match[] = {
 #ifdef CONFIG_CPU_PX30
-	{ .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
+    { .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK1808
-	{ .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
+    { .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3308
-	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+    { .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3568
-	{ .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
+    { .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3588
-	{ .compatible = "rockchip,rk3588-i2s-tdm", },
+    { .compatible = "rockchip,rk3588-i2s-tdm", },
 #endif
 #ifdef CONFIG_CPU_RV1106
-	{ .compatible = "rockchip,rv1106-i2s-tdm", },
+    { .compatible = "rockchip,rv1106-i2s-tdm", },
 #endif
 #ifdef CONFIG_CPU_RV1126
-	{ .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
+    { .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
 #endif
-	{},
+    {},
 };
 
 #ifdef HAVE_SYNC_RESET
 static int of_i2s_resetid_get(struct device_node *node,
-			      const char *id)
+              const char *id)
 {
-	struct of_phandle_args args;
-	int index = 0;
-	int ret;
-
-	if (id)
-		index = of_property_match_string(node,
-						 "reset-names", id);
-	ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
-					 index, &args);
-	if (ret)
-		return ret;
+    struct of_phandle_args args;
+    int index = 0;
+    int ret;
+
+    if (id)
+    index = of_property_match_string(node,
+         "reset-names", id);
+    ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+         index, &args);
+    if (ret)
+    return ret;
 
-	return args.args[0];
+    return args.args[0];
 }
 #endif
 
 static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
-					struct snd_soc_dai_driver **soc_dai)
+        struct snd_soc_dai_driver **soc_dai)
 {
-	struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
-		.probe = rockchip_i2s_tdm_dai_probe,
-		.playback = {
-			.stream_name = "Playback",
-			.channels_min = 2,
-			.channels_max = 16,
-//			.rates = SNDRV_PCM_RATE_8000_192000,
-			.rates = SNDRV_PCM_RATE_KNOT,
-			.formats = (SNDRV_PCM_FMTBIT_S8 |
-				    SNDRV_PCM_FMTBIT_S16_LE |
-				    SNDRV_PCM_FMTBIT_S20_3LE |
-				    SNDRV_PCM_FMTBIT_S24_LE |
-				    SNDRV_PCM_FMTBIT_S32_LE |
-				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE) |
-					SNDRV_PCM_FMTBIT_DSD_U32_LE,
-		},
-		.capture = {
-			.stream_name = "Capture",
-			.channels_min = 2,
-			.channels_max = 16,
-//			.rates = SNDRV_PCM_RATE_8000_192000,
-			.rates = SNDRV_PCM_RATE_KNOT,
-			.formats = (SNDRV_PCM_FMTBIT_S8 |
-				    SNDRV_PCM_FMTBIT_S16_LE |
-				    SNDRV_PCM_FMTBIT_S20_3LE |
-				    SNDRV_PCM_FMTBIT_S24_LE |
-				    SNDRV_PCM_FMTBIT_S32_LE |
-				    SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
-		},
-		.ops = &rockchip_i2s_tdm_dai_ops,
-	};
-
-	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
-				sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
-	if (!(*soc_dai))
-		return -ENOMEM;
+    struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+    .probe = rockchip_i2s_tdm_dai_probe,
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+        .rate_min = 8000,
+        .rate_max = 22579200,  /* DSD512 support */
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |
+        SNDRV_PCM_FMTBIT_DSD_U16_LE |
+        SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+        .rate_min = 8000,
+        .rate_max = 22579200,  /* DSD512 support */
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |
+        SNDRV_PCM_FMTBIT_DSD_U16_LE |
+        SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .ops = &rockchip_i2s_tdm_dai_ops,
+    };
+
+    *soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+    sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+    if (!(*soc_dai))
+    return -ENOMEM;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int num,
-				       bool is_rx_path)
+           int num,
+           bool is_rx_path)
 {
-	unsigned int *i2s_data;
-	int i, j, ret = 0;
+    unsigned int *i2s_data;
+    int i, j, ret = 0;
 
-	if (is_rx_path)
-		i2s_data = i2s_tdm->i2s_sdis;
-	else
-		i2s_data = i2s_tdm->i2s_sdos;
-
-	for (i = 0; i < num; i++) {
-		if (i2s_data[i] > CH_GRP_MAX - 1) {
-			dev_err(i2s_tdm->dev,
-				"%s path i2s_data[%d]: %d is overflow, max is: %d\n",
-				is_rx_path ? "RX" : "TX",
-				i, i2s_data[i], CH_GRP_MAX);
-			ret = -EINVAL;
-			goto err;
-		}
-
-		for (j = 0; j < num; j++) {
-			if (i == j)
-				continue;
-
-			if (i2s_data[i] == i2s_data[j]) {
-				dev_err(i2s_tdm->dev,
-					"%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
-					is_rx_path ? "RX" : "TX",
-					i, i2s_data[i],
-					j, i2s_data[j]);
-				ret = -EINVAL;
-				goto err;
-			}
-		}
-	}
+    if (is_rx_path)
+    i2s_data = i2s_tdm->i2s_sdis;
+    else
+    i2s_data = i2s_tdm->i2s_sdos;
+
+    for (i = 0; i < num; i++) {
+    if (i2s_data[i] > CH_GRP_MAX - 1) {
+        dev_err(i2s_tdm->dev,
+    "%s path i2s_data[%d]: %d is overflow, max is: %d\n",
+    is_rx_path ? "RX" : "TX",
+    i, i2s_data[i], CH_GRP_MAX);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    for (j = 0; j < num; j++) {
+        if (i == j)
+    continue;
+
+        if (i2s_data[i] == i2s_data[j]) {
+    dev_err(i2s_tdm->dev,
+        "%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
+        is_rx_path ? "RX" : "TX",
+        i, i2s_data[i],
+        j, i2s_data[j]);
+    ret = -EINVAL;
+    goto err;
+        }
+    }
+    }
 
 err:
-	return ret;
+    return ret;
 }
 
 static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
+
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_PATH_MASK(idx),
-				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_PATH_MASK(idx),
+       I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_PATH_MASK(idx),
-				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_PATH_MASK(idx),
+       I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					 int num, bool is_rx_path)
+         int num, bool is_rx_path)
 {
-	if (is_rx_path)
-		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
-	else
-		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
+    if (is_rx_path)
+    rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
+    else
+    rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
 }
 
 static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct device_node *np,
-					 bool is_rx_path)
+         struct device_node *np,
+         bool is_rx_path)
 {
-	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
-	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
-	char *i2s_path_prop;
-	unsigned int *i2s_data;
-	int num, ret = 0;
-
-	if (is_rx_path) {
-		i2s_path_prop = i2s_rx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdis;
-	} else {
-		i2s_path_prop = i2s_tx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdos;
-	}
-
-	num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
-	if (num < 0) {
-		if (num != -ENOENT) {
-			dev_err(i2s_tdm->dev,
-				"Failed to read '%s' num: %d\n",
-				i2s_path_prop, num);
-			ret = num;
-		}
-		goto out;
-	} else if (num != CH_GRP_MAX) {
-		dev_err(i2s_tdm->dev,
-			"The num: %d should be: %d\n", num, CH_GRP_MAX);
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = of_property_read_u32_array(np, i2s_path_prop,
-					 i2s_data, num);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to read '%s': %d\n",
-			i2s_path_prop, ret);
-		goto out;
-	}
-
-	ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to check i2s data bus: %d\n", ret);
-		goto out;
-	}
+    char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
+    char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
+    char *i2s_path_prop;
+    unsigned int *i2s_data;
+    int num, ret = 0;
+
+    if (is_rx_path) {
+    i2s_path_prop = i2s_rx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdis;
+    } else {
+    i2s_path_prop = i2s_tx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdos;
+    }
+
+    num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
+    if (num < 0) {
+    if (num != -ENOENT) {
+        dev_err(i2s_tdm->dev,
+    "Failed to read '%s' num: %d\n",
+    i2s_path_prop, num);
+        ret = num;
+    }
+    goto out;
+    } else if (num != CH_GRP_MAX) {
+    dev_err(i2s_tdm->dev,
+        "The num: %d should be: %d\n", num, CH_GRP_MAX);
+    ret = -EINVAL;
+    goto out;
+    }
+
+    ret = of_property_read_u32_array(np, i2s_path_prop,
+         i2s_data, num);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to read '%s': %d\n",
+        i2s_path_prop, ret);
+    goto out;
+    }
+
+    ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to check i2s data bus: %d\n", ret);
+    goto out;
+    }
 
-	rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
+    rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
 
 out:
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
 }
 
 static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
 }
 
-/*
 static int rockchip_i2s_tdm_get_fifo_count(struct device *dev, int stream)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int val = 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int val = 0;
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
-	else
-		regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
-
-	val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
+    else
+    regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
+
+    val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
+          ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
+          ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
+          ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
 
-	return val;
+    return val;
 }
 
 static const struct snd_dlp_config dconfig = {
-	.get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
+    .get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
 };
-*/
 
-		/* RX FIFO Overrun
 static irqreturn_t rockchip_i2s_tdm_isr(int irq, void *devid)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
-	struct snd_pcm_substream *substream;
-	u32 val;
-
-	regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
-	if (val & I2S_INTSR_TXUI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
-
-	if (val & I2S_INTSR_RXOI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "RX FIFO Overrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_CAPTURE];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
+    struct snd_pcm_substream *substream;
+    u32 val;
+
+    regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
+
+    if (val & I2S_INTSR_TXUI_ACT) {
+    dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
+    if (substream)
+        snd_pcm_stop_xrun(substream);
+    }
+
+    if (val & I2S_INTSR_RXOI_ACT) {
+    dev_warn_ratelimited(i2s_tdm->dev, "RX FIFO Overrun\n");
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+    substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_CAPTURE];
+    if (substream)
+        snd_pcm_stop_xrun(substream);
+    }
 
-	return IRQ_HANDLED;
+    return IRQ_HANDLED;
 }
-		*/
 
 static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 {
-	struct device_node *node = pdev->dev.of_node;
-	const struct of_device_id *of_id;
-	struct rk_i2s_tdm_dev *i2s_tdm;
-	struct snd_soc_dai_driver *soc_dai;
-	struct resource *res;
-	void __iomem *regs;
+    struct device_node *node = pdev->dev.of_node;
+    const struct of_device_id *of_id;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    struct snd_soc_dai_driver *soc_dai;
+    struct resource *res;
+    void __iomem *regs;
 #ifdef HAVE_SYNC_RESET
-	bool sync;
+    bool sync;
 #endif
-	int ret, val, i;//, irq;
-//+++
-	struct clk *hclk_p, *hclk_pp;
-//+++
+    int ret, val, i, irq;
 
-	ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
-	if (ret)
-		return ret;
-
-	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
-	if (!i2s_tdm)
-		return -ENOMEM;
-
-	i2s_tdm->dev = &pdev->dev;
-
-	of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
-	if (!of_id)
-		return -EINVAL;
-
-	spin_lock_init(&i2s_tdm->lock);
-	i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
-
-	for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
-		if (of_property_read_bool(node, of_quirks[i].quirk))
-			i2s_tdm->quirks |= of_quirks[i].id;
-
-	i2s_tdm->bclk_fs = 64;
-	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
-		if ((val >= 32) && (val % 2 == 0))
-			i2s_tdm->bclk_fs = val;
-	}
-
-	i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
-	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
-		if (val >= 0 && val <= 2) {
-			i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
-			if (i2s_tdm->clk_trcm)
-				soc_dai->symmetric_rates = 1;
-		}
-	}
-
-	i2s_tdm->tdm_fsync_half_frame =
-		of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
-
-	if (of_property_read_bool(node, "rockchip,playback-only"))
-		soc_dai->capture.channels_min = 0;
-	else if (of_property_read_bool(node, "rockchip,capture-only"))
-		soc_dai->playback.channels_min = 0;
+    ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+    if (ret)
+    return ret;
+
+    i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+    if (!i2s_tdm)
+    return -ENOMEM;
+
+    i2s_tdm->dev = &pdev->dev;
+    i2s_tdm->volume = 100;
+    /* Initial mute state = false (sound on) to match player expectations */
+    i2s_tdm->mute = false; 
+    
+    /* Initialize ALSA control pointers */
+    i2s_tdm->mute_kcontrol = NULL;
+    i2s_tdm->dai = NULL;
+    
+    /* Initialize MCLK multiplier - 512 by default */
+    i2s_tdm->mclk_multiplier = 512;
+    
+    /* Initialize automatic mute */
+    i2s_tdm->auto_mute_active = false;
+    i2s_tdm->user_mute_priority = false;
+    mutex_init(&i2s_tdm->mute_lock);
+    INIT_DELAYED_WORK(&i2s_tdm->mute_pre_work, rockchip_i2s_tdm_mute_pre_work);
+    INIT_DELAYED_WORK(&i2s_tdm->mute_post_work, rockchip_i2s_tdm_mute_post_work);
+    
+    /* Initialize pause state */
+    i2s_tdm->playback_paused = false;
+    i2s_tdm->capture_paused = false;
+    
+    /* Initialize debounce for auto-mute */
+    i2s_tdm->last_auto_mute_time = 0;
+    
+    /* Initialize configurable auto-mute times */
+    i2s_tdm->premute_delay_ms = DEFAULT_PREMUTE_DELAY_MS;      // default for mute stabilization
+    i2s_tdm->postmute_delay_ms = DEFAULT_POSTMUTE_DELAY_MS;    // default for mute hold
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Initial volume = %d, mute = %d (sound %s)\n", 
+     i2s_tdm->volume, i2s_tdm->mute, i2s_tdm->mute ? "OFF" : "ON");
+
+    i2s_tdm->mute_gpio = devm_gpiod_get_optional(&pdev->dev, "mute", GPIOD_OUT_LOW);
+    if (IS_ERR(i2s_tdm->mute_gpio)) {
+    ret = PTR_ERR(i2s_tdm->mute_gpio);
+    dev_err(&pdev->dev, "Failed to get mute GPIO: %d\n", ret);
+    i2s_tdm->mute_gpio = NULL;
+    } else if (i2s_tdm->mute_gpio) {
+    /* Set GPIO: mute=false -> GPIO=0 (sound on) */
+    gpiod_set_value(i2s_tdm->mute_gpio, i2s_tdm->mute ? 1 : 0);
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: GPIO mute initialized to %d (sound %s)\n", 
+         i2s_tdm->mute ? 1 : 0, i2s_tdm->mute ? "OFF" : "ON");
+    }
+
+    /* Initialize DSD-on GPIO */
+    i2s_tdm->dsd_on_gpio = devm_gpiod_get_optional(&pdev->dev, "dsd-enable", GPIOD_OUT_LOW);
+    if (IS_ERR(i2s_tdm->dsd_on_gpio)) {
+    ret = PTR_ERR(i2s_tdm->dsd_on_gpio);
+    dev_err(&pdev->dev, "Failed to get DSD-on GPIO: %d\n", ret);
+    i2s_tdm->dsd_on_gpio = NULL;
+    } else if (i2s_tdm->dsd_on_gpio) {
+    /* Initial state: DSD mode disabled */
+    i2s_tdm->dsd_mode_active = false;
+    gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO initialized to 0 (DSD mode OFF)\n");
+    }
+    
+    /* Initialize DSD sample swap to eliminate purple noise */
+    i2s_tdm->dsd_sample_swap = true;  /* Enabled by default */
+    
+    /* Initialize Channel swap controls */
+    i2s_tdm->pcm_channel_swap = false;   /* PCM channel swap disabled by default */
+    i2s_tdm->dsd_physical_swap = false;  /* DSD physical swap disabled by default */
+
+    of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+    if (!of_id)
+    return -EINVAL;
+
+    spin_lock_init(&i2s_tdm->lock);
+    i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
+
+    for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
+    if (of_property_read_bool(node, of_quirks[i].quirk))
+        i2s_tdm->quirks |= of_quirks[i].id;
+
+    i2s_tdm->bclk_fs = 64;
+    if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+    if ((val >= 32) && (val % 2 == 0))
+        i2s_tdm->bclk_fs = val;
+    }
+
+    i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+    if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+    if (val >= 0 && val <= 2) {
+        i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+        if (i2s_tdm->clk_trcm)
+    soc_dai->symmetric_rates = 1;
+    }
+    }
+
+    i2s_tdm->tdm_fsync_half_frame =
+    of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
+
+    if (of_property_read_bool(node, "rockchip,playback-only"))
+    soc_dai->capture.channels_min = 0;
+    else if (of_property_read_bool(node, "rockchip,capture-only"))
+    soc_dai->playback.channels_min = 0;
 
-	i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+    i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
 
 #ifdef HAVE_SYNC_RESET
-	sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
-
-	if (i2s_tdm->clk_trcm && sync) {
-		struct device_node *cru_node;
-
-		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
-		i2s_tdm->cru_base = of_iomap(cru_node, 0);
-		if (!i2s_tdm->cru_base)
-			return -ENOENT;
-
-		i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
-		i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
-	}
-#endif
-
-	i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
-	if (IS_ERR(i2s_tdm->tx_reset)) {
-		ret = PTR_ERR(i2s_tdm->tx_reset);
-		if (ret != -ENOENT)
-			return ret;
-	}
-
-	i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
-	if (IS_ERR(i2s_tdm->rx_reset)) {
-		ret = PTR_ERR(i2s_tdm->rx_reset);
-		if (ret != -ENOENT)
-			return ret;
-	}
-
-	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
-	if (IS_ERR(i2s_tdm->hclk))
-		return PTR_ERR(i2s_tdm->hclk);
-
-	ret = clk_prepare_enable(i2s_tdm->hclk);
-	if (ret)
-		return ret;
-
-	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
-	if (IS_ERR(i2s_tdm->mclk_tx))
-		return PTR_ERR(i2s_tdm->mclk_tx);
-
-	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
-	if (IS_ERR(i2s_tdm->mclk_rx))
-		return PTR_ERR(i2s_tdm->mclk_rx);
-
-//+++
-	//+++c
-	i2s_tdm->hclk_root_f = 0;
-	i2s_tdm->hclk_root_f =
-		of_property_read_bool(node, "my,hclk_root_f");
-
-	i2s_tdm->hclk_root_x = 0;
-	of_property_read_u32(node, "my,hclk_root_x", &i2s_tdm->hclk_root_x );
-
-	if(i2s_tdm->hclk_root_f) {
-		i2s_tdm->hclk_root = devm_clk_get(&pdev->dev, "hclk_root");
-		if(IS_ERR(i2s_tdm->hclk_root)) i2s_tdm->hclk_root_f = 0;
-	}
-
-	if (i2s_tdm->hclk_root_f) {
-		hclk_p = clk_get_parent(i2s_tdm->hclk);
-		if (!IS_ERR( hclk_p )) {
-			hclk_pp = clk_get_parent(hclk_p);
-			if (!IS_ERR( hclk_pp )) {
-				clk_set_parent( hclk_pp, i2s_tdm->hclk_root );
-			}
-		}
-	}
-	if( i2s_tdm->hclk_root_x )
-		clk_set_rate ( i2s_tdm->hclk, 44100*i2s_tdm->hclk_root_x );		// default 48000*2048 from pll0
-
-	i2s_tdm->dma_bytes = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	of_property_read_u32(node, "my,dma_bytes", &i2s_tdm->dma_bytes );
-
-	i2s_tdm->dma_burst = 8;
-	of_property_read_u32(node, "my,dma_burst", &i2s_tdm->dma_burst );
-
-	//+++c
-
-	i2s_tdm->s2mono = 0;
-	i2s_tdm->s2mono =
-		of_property_read_bool(node, "my,s2mono");
-
-	i2s_tdm->mclk_external = 0;
-	i2s_tdm->mclk_external =
-		of_property_read_bool(node, "my,mclk_external");
-
-	if (i2s_tdm->mclk_external) {
-		i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
-		if (IS_ERR(i2s_tdm->mclk_ext)) {
-			return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
-					     "Failed to get clock mclk_ext\n");
-		}
-		else {
-			i2s_tdm->mclk_ext_mux = 0;
-			i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
-			if (!IS_ERR(i2s_tdm->clk_44)) {
-				i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
-				if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
-			}
-		}
-	}
+    sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
+
+    if (i2s_tdm->clk_trcm && sync) {
+    struct device_node *cru_node;
+
+    cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+    i2s_tdm->cru_base = of_iomap(cru_node, 0);
+    if (!i2s_tdm->cru_base)
+        return -ENOENT;
+
+    i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+    i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+    }
+#endif
 
-	i2s_tdm->dcount = 0;
+    i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+    if (IS_ERR(i2s_tdm->tx_reset)) {
+    ret = PTR_ERR(i2s_tdm->tx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+    if (IS_ERR(i2s_tdm->rx_reset)) {
+    ret = PTR_ERR(i2s_tdm->rx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+    if (IS_ERR(i2s_tdm->hclk))
+    return PTR_ERR(i2s_tdm->hclk);
+
+    ret = clk_prepare_enable(i2s_tdm->hclk);
+    if (ret)
+    return ret;
+
+    i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+    if (IS_ERR(i2s_tdm->mclk_tx))
+    return PTR_ERR(i2s_tdm->mclk_tx);
+
+    i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+    if (IS_ERR(i2s_tdm->mclk_rx))
+    return PTR_ERR(i2s_tdm->mclk_rx);
 
 //+++
+    i2s_tdm->mclk_external = 0;
+    i2s_tdm->mclk_external =
+    of_property_read_bool(node, "my,mclk_external");
+    if (i2s_tdm->mclk_external) {
+    i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
+    if (IS_ERR(i2s_tdm->mclk_ext)) {
+        return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
+             "Failed to get clock mclk_ext\n");
+    }
+    else {
+        i2s_tdm->mclk_ext_mux = 0;
+        i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
+        if (!IS_ERR(i2s_tdm->clk_44)) {
+    i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
+    if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
+        }
+    }
+    }
+//+++
 
-	i2s_tdm->io_multiplex =
-		of_property_read_bool(node, "rockchip,io-multiplex");
+    i2s_tdm->io_multiplex =
+    of_property_read_bool(node, "rockchip,io-multiplex");
 
-	i2s_tdm->mclk_calibrate = 0;
-		//of_property_read_bool(node, "rockchip,mclk-calibrate");
-	if (i2s_tdm->mclk_calibrate) {
-		i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
-		if (IS_ERR(i2s_tdm->mclk_tx_src))
-			return PTR_ERR(i2s_tdm->mclk_tx_src);
-
-		i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
-		if (IS_ERR(i2s_tdm->mclk_rx_src))
-			return PTR_ERR(i2s_tdm->mclk_rx_src);
-
-		i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
-		if (IS_ERR(i2s_tdm->mclk_root0))
-			return PTR_ERR(i2s_tdm->mclk_root0);
-
-		i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
-		if (IS_ERR(i2s_tdm->mclk_root1))
-			return PTR_ERR(i2s_tdm->mclk_root1);
-
-		i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
-		i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
-		i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
-	}
-
-	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
-
-	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-						&rockchip_i2s_tdm_regmap_config);
-	if (IS_ERR(i2s_tdm->regmap))
-		return PTR_ERR(i2s_tdm->regmap);
-
-		/* RX FIFO Overrun
-	irq = platform_get_irq_optional(pdev, 0);
-	if (irq > 0) {
-		ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
-				       IRQF_SHARED, node->name, i2s_tdm);
-		if (ret) {
-			dev_err(&pdev->dev, "failed to request irq %u\n", irq);
-			return ret;
-		}
-	}
-		*/
-
-	i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
-	i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
-
-	i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
-	i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
-
-	ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
-		return ret;
-	}
-
-	ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
-		return ret;
-	}
-
-	atomic_set(&i2s_tdm->refcount, 0);
-	dev_set_drvdata(&pdev->dev, i2s_tdm);
-
-	pm_runtime_enable(&pdev->dev);
-	if (!pm_runtime_enabled(&pdev->dev)) {
-		ret = i2s_tdm_runtime_resume(&pdev->dev);
-		if (ret)
-			goto err_pm_disable;
-	}
-
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
-		unsigned int rate = DEFAULT_FS * DEFAULT_MCLK_FS;
-		unsigned int div_bclk = DEFAULT_FS * DEFAULT_MCLK_FS;
-		unsigned int div_lrck = i2s_tdm->bclk_fs;
-
-		div_bclk = DIV_ROUND_CLOSEST(rate, div_lrck * DEFAULT_FS);
-
-		/* assign generic freq */
-		clk_set_rate(i2s_tdm->mclk_rx, rate);
-		clk_set_rate(i2s_tdm->mclk_tx, rate);
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
-				   I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
-
-		if (i2s_tdm->clk_trcm)
-			rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
-		else
-			rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-
-		pm_runtime_forbid(&pdev->dev);
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
-			   I2S_DMACR_TDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
-			   I2S_DMACR_RDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
-
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
-		i2s_tdm->soc_data->init(&pdev->dev, res->start);
-
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &rockchip_i2s_tdm_component,
-					      soc_dai, 1);
-
-	if (ret) {
-		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_suspend;
-	}
-
-	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
-		return ret;
-
-	/*
-	if (of_property_read_bool(node, "rockchip,digital-loopback"))
-		ret = devm_snd_dmaengine_dlp_register(&pdev->dev, &dconfig);
-	else
-	*/
-		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
-
-	if (ret) {
-		dev_err(&pdev->dev, "Could not register PCM\n");
-		return ret;
-	}
+    i2s_tdm->mclk_calibrate =
+    of_property_read_bool(node, "rockchip,mclk-calibrate");
 
-	return 0;
+    if (i2s_tdm->mclk_calibrate) {
+    i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+    if (IS_ERR(i2s_tdm->mclk_tx_src))
+        return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+    i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+    if (IS_ERR(i2s_tdm->mclk_rx_src))
+        return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+    i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+    if (IS_ERR(i2s_tdm->mclk_root0))
+        return PTR_ERR(i2s_tdm->mclk_root0);
+
+    i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+    if (IS_ERR(i2s_tdm->mclk_root1))
+        return PTR_ERR(i2s_tdm->mclk_root1);
+
+    i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
+    i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
+    i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
+    i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
+    }
+
+    regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+    if (IS_ERR(regs))
+    return PTR_ERR(regs);
+
+    i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+        &rockchip_i2s_tdm_regmap_config);
+    if (IS_ERR(i2s_tdm->regmap))
+    return PTR_ERR(i2s_tdm->regmap);
+
+    irq = platform_get_irq_optional(pdev, 0);
+    if (irq > 0) {
+    ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
+           IRQF_SHARED, node->name, i2s_tdm);
+    if (ret) {
+        dev_err(&pdev->dev, "failed to request irq %u\n", irq);
+        return ret;
+    }
+    }
+
+    i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+    i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+    i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
+    return ret;
+    }
+    
+    /* After TX routing initialization apply DSD physical swap settings if needed */
+    rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+
+    ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
+    return ret;
+    }
+
+    atomic_set(&i2s_tdm->refcount, 0);
+    dev_set_drvdata(&pdev->dev, i2s_tdm);
+    pm_runtime_enable(&pdev->dev);
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Pause/Resume support enabled\n");
+
+    if (!pm_runtime_enabled(&pdev->dev)) {
+    ret = i2s_tdm_runtime_resume(&pdev->dev);
+    if (ret)
+        goto err_pm_disable;
+    }
+
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
+    unsigned int rate = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_bclk = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_lrck = i2s_tdm->bclk_fs;
+
+    div_bclk = DIV_ROUND_CLOSEST(rate, div_lrck * DEFAULT_FS);
+
+    /* assign generic freq */
+    clk_set_rate(i2s_tdm->mclk_rx, rate);
+    clk_set_rate(i2s_tdm->mclk_tx, rate);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
+       I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+        rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+
+    pm_runtime_forbid(&pdev->dev);
+    }
+    
+    /* Enable continuous MCLK if corresponding quirk is set */
+    if (i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON) {
+        dev_info(&pdev->dev, "MCLK always-on mode enabled\n");
+        /* Make sure MCLK is enabled and will remain enabled */
+        ret = clk_prepare_enable(i2s_tdm->mclk_tx);
+        if (ret) {
+            dev_err(&pdev->dev, "Failed to enable mclk_tx for always-on: %d\n", ret);
+            goto err_pm_disable;
+        }
+        ret = clk_prepare_enable(i2s_tdm->mclk_rx);
+        if (ret) {
+            dev_err(&pdev->dev, "Failed to enable mclk_rx for always-on: %d\n", ret);
+            clk_disable_unprepare(i2s_tdm->mclk_tx);
+            goto err_pm_disable;
+        }
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+           I2S_DMACR_TDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+           I2S_DMACR_RDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+    if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
+    i2s_tdm->soc_data->init(&pdev->dev, res->start);
+
+    /* Try to register component with audiophile processing support */
+    ret = devm_snd_soc_register_component(&pdev->dev,
+              &rockchip_i2s_tdm_component_with_copy,
+              soc_dai, 1);
+
+    if (ret) {
+    dev_warn(&pdev->dev, "Failed to register component with copy support: %d\n", ret);
+    dev_info(&pdev->dev, "Falling back to standard component (no volume processing)\n");
+    
+    /* Fallback to standard component */
+    ret = devm_snd_soc_register_component(&pdev->dev,
+                  &rockchip_i2s_tdm_component,
+                  soc_dai, 1);
+    if (ret) {
+        dev_err(&pdev->dev, "Could not register DAI\n");
+        goto err_suspend;
+    }
+    } else {
+    dev_info(&pdev->dev, "Audiophile component registered successfully with copy callbacks\n");
+    }
+
+    if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+    return ret;
+
+    if (of_property_read_bool(node, "rockchip,digital-loopback"))
+    ret = devm_snd_dmaengine_dlp_register(&pdev->dev, &dconfig);
+    else
+    /* Use custom configuration with pause/resume support */
+    ret = devm_snd_dmaengine_pcm_register(&pdev->dev, 
+             &rockchip_i2s_tdm_dmaengine_pcm_config, 
+             0);
+    if (ret) {
+    dev_err(&pdev->dev, "Could not register PCM\n");
+    return ret;
+    }
+
+    /* Create sysfs attribute for MCLK multiplier switching */
+    ret = device_create_file(&pdev->dev, &dev_attr_mclk_multiplier);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create mclk_multiplier sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+
+    
+    /* Create sysfs attribute for DSD sample swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_dsd_sample_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create dsd_sample_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for PCM channel swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_pcm_channel_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create pcm_channel_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for DSD physical swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_dsd_physical_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create dsd_physical_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for premute delay */
+    ret = device_create_file(&pdev->dev, &dev_attr_premute_delay_ms);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create premute_delay_ms sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for postmute delay */
+    ret = device_create_file(&pdev->dev, &dev_attr_postmute_delay_ms);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create postmute_delay_ms sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for mute control */
+    ret = device_create_file(&pdev->dev, &dev_attr_mute);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create mute sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+
+    return 0;
 
 err_suspend:
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
 err_pm_disable:
-	pm_runtime_disable(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
-
-	pm_runtime_disable(&pdev->dev);
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
-	clk_disable_unprepare(i2s_tdm->hclk);
+    /* Cleanup auto-mute timers */
+    cancel_delayed_work_sync(&i2s_tdm->mute_pre_work);
+    cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
+
+    /* Remove sysfs attributes */
+    device_remove_file(&pdev->dev, &dev_attr_mclk_multiplier);
+    device_remove_file(&pdev->dev, &dev_attr_dsd_sample_swap);
+    device_remove_file(&pdev->dev, &dev_attr_pcm_channel_swap);
+    device_remove_file(&pdev->dev, &dev_attr_dsd_physical_swap);
+
+    pm_runtime_disable(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
+
+    /* Turn off MCLK regardless of quirk when removing driver */
+    clk_disable_unprepare(i2s_tdm->mclk_tx);
+    clk_disable_unprepare(i2s_tdm->mclk_rx);
+    clk_disable_unprepare(i2s_tdm->hclk);
 
-	return 0;
+    return 0;
 }
 
 static void rockchip_i2s_tdm_platform_shutdown(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	pm_runtime_get_sync(i2s_tdm->dev);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
-	pm_runtime_put(i2s_tdm->dev);
+    pm_runtime_get_sync(i2s_tdm->dev);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
+    pm_runtime_put(i2s_tdm->dev);
 }
 
 #ifdef CONFIG_PM_SLEEP
 static int rockchip_i2s_tdm_suspend(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 
-	regcache_mark_dirty(i2s_tdm->regmap);
+    regcache_mark_dirty(i2s_tdm->regmap);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_resume(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int ret;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
+
+    ret = pm_runtime_get_sync(dev);
+    if (ret < 0)
+    return ret;
 
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
-		return ret;
-	ret = regcache_sync(i2s_tdm->regmap);
-	pm_runtime_put(dev);
+    ret = regcache_sync(i2s_tdm->regmap);
 
-	return ret;
+    pm_runtime_put(dev);
+
+    return ret;
 }
 #endif
 
 static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
-	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
-			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
-				rockchip_i2s_tdm_resume)
+    SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+           NULL)
+    SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+    rockchip_i2s_tdm_resume)
 };
 
 static struct platform_driver rockchip_i2s_tdm_driver = {
-	.probe = rockchip_i2s_tdm_probe,
-	.remove = rockchip_i2s_tdm_remove,
-	.shutdown = rockchip_i2s_tdm_platform_shutdown,
-	.driver = {
-		.name = DRV_NAME,
-		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
-		.pm = &rockchip_i2s_tdm_pm_ops,
-	},
+    .probe = rockchip_i2s_tdm_probe,
+    .remove = rockchip_i2s_tdm_remove,
+    .shutdown = rockchip_i2s_tdm_platform_shutdown,
+    .driver = {
+    .name = DRV_NAME,
+    .of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+    .pm = &rockchip_i2s_tdm_pm_ops,
+    },
 };
+
 module_platform_driver(rockchip_i2s_tdm_driver);
 
-MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
+MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface with Fixed-Point Audiophile Enhancement");
 MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
\ No newline at end of file
